<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="shiwi"><meta name="copyright" content="SHIWIVI"><link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon"><style>.preload{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;left:0;top:0;width:100%;height:100%;background-color:#000;z-index:100}.text{margin-bottom:10px;color:#00cff3;text-shadow:0 0 3px #00cff3;font-size:20px}.text span{display:inline-block}.dance{animation:dance .8s linear}.text span:nth-child(1){animation-delay:0s}.text span:nth-child(2){animation-delay:.1s}.text span:nth-child(3){animation-delay:.2s}.text span:nth-child(4){animation-delay:.3s}.text span:nth-child(5){animation-delay:.4s}.text span:nth-child(6){animation-delay:.5s}.text span:nth-child(7){animation-delay:.6s}.text span:nth-child(8){animation-delay:.7s}.text span:nth-child(9){animation-delay:.8s}.text span:nth-child(10){animation-delay:.9s}@keyframes dance{0%{transform:translateY(0)}50%{transform:translateY(-20px)}100%{transform:translateY(0)}}.loading{width:80%;max-width:260px;height:6px;background-color:#e1e4e8;border-radius:6px}.bar{display:flex;height:100%;background:linear-gradient(90deg,#ffd33d,#ea4aaa 10%,#b34bff 30%,#01feff 51%,#ffb33d 68%,#ea4aaa 85%,#b34bff);background-size:300% 100%;animation:bar 2s linear infinite}@keyframes bar{0%{background-position:100%}100%{background-position:0}}</style><body><div class="preload"><div class="text"><span>L</span> <span>o</span> <span>a</span> <span>d</span> <span>i</span> <span>n</span> <span>g</span> <span>.</span> <span>.</span> <span>.</span></div><div class="loading"><span class="bar"></span></div></div><script>let texts=document.querySelector('.text').querySelectorAll('span');let timer=setInterval(()=>{texts.forEach((item)=>{item.classList.toggle("dance")})},1700);window.onload=function(){clearInterval(timer);document.querySelector('.preload').style="display:none;"}</script><title>SHIWIVI-文章</title>
<link rel="stylesheet" href="https://at.alicdn.com/t/font_2856826_bu73u0ahu7a.css">

<link rel="stylesheet" href="/blog/css/index.css">
<link rel="stylesheet" href="/blog/css/article.css">
<link rel="stylesheet" href="/blog/css/atelier-cave.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="SHWIVI's blog" type="application/atom+xml">
</head>
<body>
<div class="nav">
    <div class="card">
        <div class="head">
            <img src="/blog/images/head.jpg"  alt="头不见了.." title="狗">
        </div>
        <div class="card-text">
            <p>(ー`´ー)</p>
            <p>那不是bug，是彩蛋</p>
        </div> 
    </div>
    <ul class="label">
        
        <li><a href="/blog/index.html">首页</a></li>
        
        <li><a href="/blog/life">日常</a></li>
        
        <li><a href="/blog/record">一句</a></li>
        
        <li><a href="/blog/message">留言</a></li>
        
        <li><a href="/blog/about">关于</a></li>
          
    </ul>
        <ul class="tag">
            <li><a href="/blog/tags/Command">#Command</a></li>
            <li>#Java</li>
            <li><a href="/blog/tags/Css">#Css</a></li>
            <li><a href="/blog/tags/Life">#Life</a></li>
            <li>#Lua</li>
            <li><a href="/blog/tags/PCB">#PCB</a></li>
            <li><a href="/blog/tags/Shell">#Shell</a></li>
            <li><a href="/blog/tags/C">#C</a></li>
            <li><a href="/blog/tags/html">#html</a></li>
            <li><a href="/blog/tags/%E7%A1%AC%E4%BB%B6">#硬件</a></li>
            <li><a href="/blog/tags/JavaScrip">#JavaScript</a></li>
            <li><a href="/blog/tags/Firewall">#Firewall</a></li>
            <li>#Security</li>
            <li><a href="/blog/tags/Linux">#Linux</a></li>
            <li>#Python</li>
            <li><a href="/blog/tags/Server">#Server</a></li>
            <li><a href="/blog/tags/Web">#Web</a></li>
        </ul>
    <div class="rsstag"><a href="/blog/atom.xml"><span class="iconfont icon-rss"></span>RSS订阅</a></div>
<div class="flower">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="84.6px" height="70.5px" viewBox="0 0 254 212" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>窗</title>
<desc>Created with Sketch.</desc>
<defs></defs>
<g id="植物" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="Artboard" transform="translate(-885.000000, -503.000000)">
        <g id="植物-紫色盆" transform="translate(882.000000, 500.000000)">
            <ellipse id="Oval-12" fill="#B3B7C7" cx="140.5" cy="137" rx="39.5" ry="6"></ellipse>
            <g id="Group-5">
                <path d="M131.5,149 C137.746054,149 138.400559,136.953074 140.297813,118.503702 C141.504079,106.77367 149.145158,88.1140929 147,75 C142.297813,46.2539062 153.271934,32.5660626 150.170125,19.4282488 C148.031314,10.3692495 142.862042,3 131.5,3 C123.603887,3 113.698654,6.59314895 110.722909,11.2157433 C103.206874,22.8913341 114,46.5137576 114,75 C114,90.4435309 122.495151,106.751425 123.699377,118.476362 C125.595832,136.941172 125.250862,149 131.5,149 Z" id="Oval-11" fill="#BAC4F6"></path>
                <path d="M135.5,146.5 C132.598908,121.877878 130.965369,104.566553 130.599381,94.5660242 C130.050399,79.5652312 132.963841,77.0580598 132.164069,55.3464601 C131.630888,40.8720602 130.242865,30.4232402 128,24" id="Line-15" stroke="#FFFFFF" stroke-width="2" opacity="0.800892857" stroke-linecap="square"></path>
                <path d="M77.0442201,163.336077 C84.2239219,163.336077 101.067658,131.237823 101.067658,92.025606 C101.067658,52.8133888 90.9057581,-2.32627732 72.6560979,17.2440872 C50.0508064,41.4852946 69.5871262,36.5862429 74.0442201,63.8595149 C75.572858,73.2133576 77.0442201,94.5993942 77.0442201,104.613421 C77.0442201,143.825638 69.8645184,163.336077 77.0442201,163.336077 Z" id="Oval-9" fill="#BAC4F6" transform="translate(81.510722, 88.251316) rotate(-43.000000) translate(-81.510722, -88.251316) "></path>
                <path d="M42.5,50.5 C47.5132933,48.8699207 59.3816332,57.6317857 78.1050199,76.785595 C96.8284065,95.9394043 113.960067,116.844206 129.5,139.5" id="Line-17" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M155.281006,152.144255 C162.116643,152.144255 178.153197,121.584207 178.153197,84.2511084 C178.153197,72.6051871 184.354199,51.8242671 182.531201,39.8465879 C178.51025,13.4276595 163.058175,0.233079666 151.10317,13.0532528 C129.581164,36.1327785 143.297279,29.7382802 147.540781,55.7045685 C148.996164,64.6101585 153.500382,80.3852665 153.500382,89.9194035 C153.500382,127.252502 148.445368,152.144255 155.281006,152.144255 Z" id="Oval-9-Copy-2" fill="#E9EDFD" transform="translate(161.092971, 80.123972) scale(-1, 1) rotate(-20.000000) translate(-161.092971, -80.123972) "></path>
                <path d="M180.5,34.5 C181.290102,21.4892162 175.746138,28.9223292 163.868108,56.7993391 C157.546037,71.6368512 150.532373,85.3308057 144.827114,101.881203 C141.023608,112.914801 138.581237,128.787733 137.5,149.5" id="Line-20" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M60.3426107,183.894782 C69.2498271,183.894782 90.1463498,156.072081 90.1463498,122.083011 C90.1463498,88.0939419 67.5408019,29.4364067 54.8986583,57.2625442 C45.0326912,78.978146 51.0912584,74.0282851 56.6207779,97.6687014 C58.5172227,105.776593 67.8616068,124.363423 67.8616068,133.043561 C67.8616068,167.032631 51.4353942,183.894782 60.3426107,183.894782 Z" id="Oval-9-Copy" fill="#BAC4F6" transform="translate(69.895982, 116.944107) rotate(-71.000000) translate(-69.895982, -116.944107) "></path>
                <path d="M24.5,109.5 C22.4991751,103.669523 35.0833631,105.49608 62.2525641,114.979669 C79.4278854,120.974828 92.103247,119.378882 106.278649,126.191831 C111.777518,128.834684 120.517968,134.937407 132.5,144.5" id="Line-19" stroke="#FFFFFF" stroke-width="2" opacity="0.595424107" stroke-linecap="square"></path>
                <path d="M169.495543,159.559977 C178.40276,159.559977 199.299282,131.737276 199.299282,97.7482062 C199.299282,85.7856682 202.004463,66.329956 197.824033,53.1018748 C190.126639,28.745108 172.2443,14.8950801 164.051591,32.9277389 C154.185624,54.6433407 160.244191,49.6934798 165.77371,73.3338961 C167.670155,81.4417878 177.014539,100.028618 177.014539,108.708756 C177.014539,142.697825 160.588327,159.559977 169.495543,159.559977 Z" id="Oval-9-Copy-3" fill="#BAC4F6" transform="translate(179.479352, 92.134636) scale(-1, 1) rotate(-43.000000) translate(-179.479352, -92.134636) "></path>
                <path d="M213.5,60.5 C209.183273,60.8948914 201.740861,65.4428024 191.172763,74.1437328 C175.320617,87.1951284 177.797205,83.2393994 161.560337,103.262986 C150.735758,116.612043 142.715646,131.024381 137.5,146.5" id="Line-21" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M81.1425752,168.630026 C85.1025169,165.536181 98.2051544,147.96348 98.2051544,111.236918 C98.2051544,74.5103552 86.0176544,46.7369177 70.0176544,46.7369177 C54.0176544,46.7369177 59.5351666,70.3889964 66.8400325,93.0530589 C69.6371249,101.731312 78.9791535,122.814465 81.0032985,132.88325 C84.2653955,149.110029 78.6989273,170.539213 81.1425752,168.630026 Z" id="Oval-10" fill="#E9EDFD" transform="translate(78.936475, 107.743055) rotate(-52.000000) translate(-78.936475, -107.743055) "></path>
                <path d="M39.5,84.5 C46.5402399,84.832105 55.9862242,87.7506309 67.8379528,93.2555776 C85.6155457,101.512998 79.9127462,96.6348296 100.298442,112.739947 C113.888906,123.476691 125.956092,135.063376 136.5,147.5" id="Line-18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M194.823347,177.534556 C197.785465,175.220296 209.085075,165.125173 213.530819,146.109724 C215.496552,137.701844 211.555235,124.000271 211.555235,111.853141 C211.555235,72.2337887 199.639103,43.8487815 182.378853,43.8487815 C165.118604,43.8487815 168.053621,58.2764613 175.933859,82.7256721 C183.814096,107.174883 191.693317,118.61017 193.876895,129.472028 C197.395933,146.976919 192.187224,179.594121 194.823347,177.534556 Z" id="Oval-10-Copy-2" fill="#E9EDFD" transform="translate(191.881132, 110.738214) scale(-1, 1) rotate(-52.000000) translate(-191.881132, -110.738214) "></path>
                <path d="M237.5,84.5 C231.839918,82.6252532 222.387737,84.7837206 209.143456,90.9754021 C189.277034,100.262925 198.344222,96.9653923 174.587666,113.911421 C158.749962,125.208774 147.387407,137.071634 140.5,149.5" id="Line-22" stroke="#FFFFFF" stroke-width="2" opacity="0.785044643" stroke-linecap="square"></path>
                <path d="M102.095097,154.049614 C106.979303,150.233654 123.140143,128.559423 123.140143,83.2607523 C123.140143,37.9620813 108.108037,3.70622602 88.3735811,3.70622602 C68.639125,3.70622602 75.4444439,32.8787829 84.4542911,60.8327171 C87.9042347,71.5365054 99.4267255,97.5405402 101.923313,109.959415 C105.946795,129.97358 99.0810936,156.404412 102.095097,154.049614 Z" id="Oval-10-Copy" fill="#E9EDFD" transform="translate(99.374086, 78.951409) rotate(-21.000000) translate(-99.374086, -78.951409) "></path>
                <path d="M70.5,27.5 C77.9697854,36.2141564 84.664658,44.2949462 90.5846178,51.7423694 C99.4645574,62.9135043 102.309139,65.8595669 108.078018,74.773869 C113.846897,83.6881711 108.232283,69.1486166 118.500716,94.8794382 C125.346337,112.033319 129.012765,128.573507 129.5,144.5" id="Line-16" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M193.001521,189.153265 C198.929205,189.153265 212.83568,162.652399 212.83568,130.278124 C212.83568,97.9038493 204.210737,49.7003434 189.378612,68.5372278 C174.540517,87.3816949 180.150684,86.5530431 183.830536,109.070321 C185.092606,116.793013 193.001521,132.403088 193.001521,140.670839 C193.001521,173.045114 187.073837,189.153265 193.001521,189.153265 Z" id="Oval-9-Copy-4" fill="#BAC4F6" transform="translate(196.248002, 126.727326) scale(-1, 1) rotate(-73.000000) translate(-196.248002, -126.727326) "></path>
                <path d="M234.5,116.5 C229.435614,115.997419 220.043174,117.148484 206.322678,119.953197 C185.741934,124.160265 185.201799,123.9696 168.145826,131.063968 C156.775178,135.793546 148.226569,140.93889 142.5,146.5" id="Line-23" stroke="#FFFFFF" stroke-width="2" opacity="0.733426339" stroke-linecap="square"></path>
            </g>
            <g id="Group-4" transform="translate(101.000000, 137.000000)">
                <path d="M0,0 C11.7955729,2 24.5052083,3 38.1289062,3 C51.7526042,3 65.3763021,2 79,0 L71.2109375,75.3409091 C61.9375,77.1136364 51.8945312,78 41.0820312,78 C30.2695313,78 19.4570312,77.1136364 8.64453125,75.3409091 L0,0 Z" id="Rectangle-9" fill="#FCDCCF"></path>
                <path d="M59.2621996,2.19791001 C63.6483775,1.86496527 70.2276443,1.1323286 79,0 L71.2109375,75.3409091 C63.3055851,76.5844933 57.2271178,77.3450382 52.9755357,77.6225437 L59.2621996,2.19791001 Z" id="Rectangle-9" fill="#ECC6B6"></path>
                <path d="M0,0 C10.9588352,1.33333333 23.3572727,2 37.1953125,2 C51.0333523,2 64.9682481,1.33333333 79,0 L76.7909585,21.3672948 L40.573652,23.0934676 L2.38711382,20.8047516 L0,0 Z" id="Rectangle-9" fill="#F3B096"></path>
            </g>
        </g>
    </g>
</g>
</svg>
</div>

</div>
<div class="menu-btn closed"> 
    <div class="menu-line"></div>
    <div class="menu-line"></div>
    <div class="menu-line"></div>
</div>
<div class="main">
    <div class="msg">
        <div class="msg-text"></div>
        <div class="msg-bar"></div>
    </div>
    <div class="motto">
        <p> //sunny forever<br />
            while(life&lt;end){<br />
               love++;<br />
               beAwesome :)} </p>
     </div>
     <div class="main-content">
    <div class="set-wrapper">
    <ul class="set-menu">
        <div id="set-btn" class="set-button"><</div>
        <li class="search-container">
            <input id="search-input" class="local-search" placeholder="搜索..." type="search" >
            <span class="search-ico"></span>
        </li>
        <li id="toggle-theme">
        主题：<span class="theme-ico sun"></span>
        </li>
        <li class="set-size">
            <span id="increase-font-size">+</span>
            <span class="font-size-num"></span>
            <span id="reduce-font-size">-</span>
        </li>
        <li id="clear-back">清除背景</li>
        <li id="disable-back">禁用背景</li>
    </ul> 
</div>
    <div class="result-container">
        <div id="search-result" class="display-result"></div>
    </div>
    <div class="toc-wrapper"><div class="toc-btn">目 录</div><div class="toc-box"><!--tocBox用于容纳生成在toc外的目录--><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.</span> <span class="toc-text">Bash常用快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">shell介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shell%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">shell简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2shell"><span class="toc-number">2.2.</span> <span class="toc-text">切换shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90shell"><span class="toc-number">2.3.</span> <span class="toc-text">父子shell</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%88%B6%E5%AD%90shell%E7%9A%84%E5%88%9B%E5%BB%BA%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">查看父子shell的创建关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E5%AD%90shell%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">父子shell的使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">内建命令与外部命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">外部命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">内建命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.</span> <span class="toc-text">命令的执行优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%88%86%E7%BB%84%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.</span> <span class="toc-text">命令分组执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">创建协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">Bash的内建命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bash%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">Bash的启动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#history%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">history历史命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-number">4.2.1.</span> <span class="toc-text">调用历史命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alias%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%90%8D"><span class="toc-number">4.3.</span> <span class="toc-text">alias自定义命令名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">type查询命令类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#command%E6%89%A7%E8%A1%8C%E5%8E%9F%E5%A7%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">4.5.</span> <span class="toc-text">command执行原始命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%AE%A1%E7%90%86shell%E5%8A%9F%E8%83%BD"><span class="toc-number">4.6.</span> <span class="toc-text">set管理shell功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">4.7.</span> <span class="toc-text">:空操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapfile%E5%B0%86%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E7%BB%84"><span class="toc-number">4.8.</span> <span class="toc-text">mapfile将标准输入存储到数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%91%BD%E4%BB%A4"><span class="toc-number">4.9.</span> <span class="toc-text">exec命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%BD%93%E5%89%8Dshell%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.9.1.</span> <span class="toc-text">替换当前shell进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.9.2.</span> <span class="toc-text">修改文件描述符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-%E4%B8%8E-gt-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.</span> <span class="toc-text">&lt;()与&gt;()重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">常用通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">6.2.</span> <span class="toc-text">{..}花括号扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">扩展通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">POSIX字符类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">全局环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.2.</span> <span class="toc-text">局部环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bash%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.</span> <span class="toc-text">Bash中的环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">环境变量配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.1.</span> <span class="toc-text">全局配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.2.</span> <span class="toc-text">用户配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E5%90%AF%E5%B0%B1%E4%BD%BF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88"><span class="toc-number">8.4.3.</span> <span class="toc-text">不重启就使配置文件生效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.5.</span> <span class="toc-text">不同启动方式读取的配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">8.6.</span> <span class="toc-text">环境变量的持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">终端控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ANSI%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97"><span class="toc-number">9.1.</span> <span class="toc-text">ANSI转义字符序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSI%E5%BA%8F%E5%88%97"><span class="toc-number">9.2.</span> <span class="toc-text">CSI序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E6%8E%A7%E5%88%B6"><span class="toc-number">9.3.1.</span> <span class="toc-text">光标控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%8E%A7%E5%88%B6"><span class="toc-number">9.3.2.</span> <span class="toc-text">屏幕控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">修改字体样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E9%BB%98%E8%AE%A4"><span class="toc-number">9.4.1.</span> <span class="toc-text">恢复默认</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C"><span class="toc-number">9.4.2.</span> <span class="toc-text">文字效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2-%E5%89%8D%E6%99%AF%E8%89%B2"><span class="toc-number">9.4.3.</span> <span class="toc-text">字体颜色(前景色)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E8%83%8C%E6%99%AF%E8%89%B2"><span class="toc-number">9.4.4.</span> <span class="toc-text">字体背景色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%A2%9C%E8%89%B2"><span class="toc-number">9.4.5.</span> <span class="toc-text">修改文件目录颜色</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSC%E5%BA%8F%E5%88%97"><span class="toc-number">9.5.</span> <span class="toc-text">OSC序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSC%E5%87%BD%E6%95%B0%E5%80%BC"><span class="toc-number">9.6.</span> <span class="toc-text">OSC函数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-number">9.7.</span> <span class="toc-text">修改命令提示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E6%A0%87%E9%A2%98"><span class="toc-number">9.8.</span> <span class="toc-text">终端标题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E5%89%8D%E7%9A%84%E6%AC%A2%E8%BF%8E%E4%BF%A1%E6%81%AF"><span class="toc-number">9.9.</span> <span class="toc-text">本地终端登录前的欢迎信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E5%89%8D%E7%9A%84%E6%AC%A2%E8%BF%8E%E4%BF%A1%E6%81%AF"><span class="toc-number">9.10.</span> <span class="toc-text">远程终端登录前的欢迎信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">9.11.</span> <span class="toc-text">终端登录成功后的提示信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tput-%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%A0%87%E5%87%86%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">tput 终端控制标准化接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Terminfo%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">10.1.1.</span> <span class="toc-text">Terminfo数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tput%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7"><span class="toc-number">10.1.2.</span> <span class="toc-text">tput命令工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8ECSI%E6%8E%A7%E5%88%B6%E5%BA%8F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.3.</span> <span class="toc-text">与CSI控制序列的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tput%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">tput命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACterminfo%E5%8A%9F%E8%83%BD"><span class="toc-number">10.3.</span> <span class="toc-text">基本terminfo功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E6%8E%A7%E5%88%B6"><span class="toc-number">10.4.</span> <span class="toc-text">颜色控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">10.5.</span> <span class="toc-text">文字样式控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E6%8E%A7%E5%88%B6-1"><span class="toc-number">10.6.</span> <span class="toc-text">光标控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%A6%E9%99%A4%E8%A1%8C"><span class="toc-number">10.7.</span> <span class="toc-text">擦除行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4%E8%A1%8C%E4%B8%8E%E5%88%97"><span class="toc-number">10.8.</span> <span class="toc-text">插入&#x2F;删除行与列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%B1%8F%E5%B9%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">10.9.</span> <span class="toc-text">切换屏幕缓冲区</span></a></li></ol></li></ol></div></div>
        <div class="article">
        <h1 class="title">Shell与Bash</h1>
        <div class="art-info">
            <div><span><span class="iconfont icon-zishu-jzl"></span>字数：11482</span>
            <span><span class="iconfont icon-riqi"></span>写于：2021-12-29</span></div>
            <div><span><span class="iconfont icon-zuixinnew3"></span>最新更新：2024-06-02</span>
            <span><span class="iconfont icon-shijian"></span>阅读本文预计花费您33分钟</span></div>
        </div>
        <div class="art-content">
        <h3 id="Bash常用快捷键"><a href="#Bash常用快捷键" class="headerlink" title="Bash常用快捷键"></a>Bash常用快捷键</h3><p>修改快捷键参考stty命令</p>
<div class="table">

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+a</td>
<td>将光标跳转到命令行开头</td>
</tr>
<tr>
<td>ctrl+e</td>
<td>将光标跳转到命令行末尾</td>
</tr>
<tr>
<td>ctrl+左箭头</td>
<td>光标向左(前)跳转一个单词，esc+b也可以</td>
</tr>
<tr>
<td>ctrl+右箭头</td>
<td>光标向右(后)跳转一个单词，esc+f也可以</td>
</tr>
<tr>
<td>ctrl+u</td>
<td>剪切光标到行首之间的内容(也用来快速删除一整行命令)</td>
</tr>
<tr>
<td>ctrl+k</td>
<td>剪切光标到行尾之间的内容</td>
</tr>
<tr>
<td>ctrl+y</td>
<td>粘贴剪切的内容</td>
</tr>
<tr>
<td>clear</td>
<td>清屏</td>
</tr>
<tr>
<td>ctrl+l</td>
<td>清屏，同clear命令</td>
</tr>
<tr>
<td>exit</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>ctrl+d</td>
<td>如果命令行中有输入,则终止输入并提交;如果命令行中无输入,则为退出当前终端，同exit命令</td>
</tr>
<tr>
<td>ctrl+c</td>
<td>强制终止当前任务</td>
</tr>
<tr>
<td>ctrl+z</td>
<td>暂停当前任务并放入后台</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>反向搜索执行过的历史命令</td>
</tr>
<tr>
<td>#</td>
<td>root用户的命令提示符</td>
</tr>
<tr>
<td>$</td>
<td>非root用户的命令提示符</td>
</tr>
<tr>
<td>&gt;</td>
<td>次提示符</td>
</tr>
<tr>
<td>\</td>
<td>延续字符</td>
</tr>
</tbody></table>
</div>
<div class="broadcast color-blue">
<div class="iconfont icon-yinhao"></div>
GUN官方的Bash文档：<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/bash.html">Bash Reference Manual</a></div>

<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><h4 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h4><p>shell意为层壳，区别于操作系统Kernel(内核)，shell是一个命令行解释器，主要用来与用户交互，将用户的命令解释给操作系统，是用户与操作系统内核交互的桥梁，它提供文件操作、进程控制、环境变量设置、管道和重定向等各种功能，因此，Shell 也是许多脚本和自动化任务的基础。此外，shell还有一套自己的编程语法，用于编写shell脚本，shell脚本支持直接调用Linux系统命令</p>
<p>常见的类Unix操作系统中的Shell程序包括：</p>
<ul>
<li>sh(Bourne Shell)：是Unix系统上最早的shell，由Stephen Bourne于1977年在AT&amp;T贝尔实验室开发。尽管现在有许多更现代的shell可以使用，但许多Unix系统命令和脚本仍然使用sh作为默认解释器</li>
<li>Bash(Bourne-Again SHell)： bash是Bourne Shell的增强版，兼容sh的命令和脚本，并结合了ksh、csh的有用功能。作为GNU项目的一部分，它具有强大的功能和灵活性，支持命令历史、自动补全、脚本编程等功能，是许多Linux系统的默认Shell</li>
<li>Csh(C Shell)：csh是基于C语言语法的shell，它提供了类似于C语言的语法结构和编程特性，由Bill Joy于1978年开发</li>
<li>Tcsh（TC Shell）：Tcsh是C Shell的改进版本，提供了更多的功能和灵活性</li>
<li>Fish（Friendly Interactive Shell）：Fish是一个用户友好的交互式shell软件，具有直观的语法和自动补全功能，还提供了颜色高亮和语法提示等功能，被广泛包含于如 Debian、Ubuntu、Fedora、Gentoo、Arch 等操作系统中</li>
<li>Ksh(Korn Shell)：由贝尔实验室的David Korn在1983年基于Bourne shell的源码开发，它结合了Bourne Shell和C Shell的特性，并引入了许多新的功能</li>
<li>Zsh(Z Shell)：由普林斯顿大学的Paul Falstad开发，它包含了 bash，ksh，tcsh 等其他shell中许多优秀功能，可以作为bash的替代品，它也是macOS 10.15及新版系统的默认shell</li>
</ul>
<p>在这些众多的shell中，有一些shell软件有类似的语法和特性，由此形成了两大家族：Bourne Shell家族：通常为Linux的默认使用终端，包括sh、ksh、Bash、psh、zsh。以及C Shell家族：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统。</p>
<h4 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h4><p>查看<span class="tips">/etc/shells</span>文件可获取当前Linux支持的shell列表，绝大多数Linux发行版默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class="tips"><strong>exit</strong></span>命令返回默认的Bash终端</p>
<h4 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h4><p>默认情况下，系统会在用户登录时根据<span class="tips">/etc/passwd</span>文件第7字段的设置启动用户的默认shell，这是一个<span class="text-blue">父shell</span>，如果此时输入bash或其他shell的启动命令，会创建一个新的shell程序，这个shell程序是一个<span class="text-blue">子shell</span>。</p>
<p>创建子shell可以保持父子进程环境的纯洁性，创建子shell时，只有部分父进程环境会被复制到子shell中，因此子shell会在一个相对纯洁的环境中执行任务，但这也会造成父shell中的一些变量(如用户自定义的局部变量)无法被子shell中继承使用。在子shell中执行一些独立任务，或者修改一些环境也不会影响到父进程的执行。但是创建子shell成本不菲，它会显著占用一部分系统资源</p>
<p>以下操作会创建一个子shell：</p>
<ul>
<li>通过<span class="tips">bash</span>等命令显式调用shell解释器，会启动一个新的子shell</li>
<li>通过<span class="tips">bash filename.sh</span>或<span class="tips">./filename.sh</span>方式执行shell脚本时，会创建一个子shell执行该脚本。相对的，通过source filename.sh或.filename.sh方式执行脚本，会在当前shell中执行而不会创建子shell</li>
<li>在命令中使用管道符<span class="tips">|</span>时，shell会创建子shell，管道两边的命令都会在单独的子shell中执行。</li>
<li>使用反引号<span class="tips">` `</span>或<span class="tips">$()</span>执行命令替换时，命令会在子shell中执行</li>
<li>将命令放到<span class="tips">( )</span>中，所有括号中的命令会在子shell中执行，这是最直接创建子shell的方式，通常用来执行多个需要在同一个shell环境中执行的一组命令</li>
<li>使用<span class="tips">&amp;</span>将任务放到后台执行时，为了不阻塞当前shell执行其他任务，bash会在后台创建子shell执行命令</li>
</ul>
<h5 id="查看父子shell的创建关系"><a href="#查看父子shell的创建关系" class="headerlink" title="查看父子shell的创建关系"></a>查看父子shell的创建关系</h5><p>子shell也可以创建另一个子shell，产生嵌套，通过<span class="tips">ps -f</span>命令查看shell程序的PPID来查找其父进程</p>
<div class="shell">UID        PID  PPID  C STIME TTY          TIME CMD
root     27576 27573  0 15:11 pts/0    00:00:00 -bash #父shell
root     27602 27576  0 15:11 pts/0    00:00:00 bash  #子shell，父进程PID为27576
root     27619 27602  0 15:11 pts/0    00:00:00 ps -f
</div>
也可以通过<span class="tips">ps -&zwnj;-forest</span>命令查看子shell的嵌套结构
<div class="shell">  PID TTY          TIME CMD
27576 pts/0    00:00:00 bash
27602 pts/0    00:00:00  \_ bash
27923 pts/0    00:00:00      \_ bash
27939 pts/0    00:00:00          \_ bash
28000 pts/0    00:00:00              \_ ps
</div>

<p>也可以通过输出环境变量<span class="tips">BASH_SUBSHELL</span>来查看当前bash有没有生成子shell，如果该命令返回0，则表明没有子shell，返回1或其他更大的值，就表明有相应数量的子shell。但该命令需要在父shell环境下执行，因此一般在命令分组并形成进程列表时使用</p>
<div class="shell">(pwd;ls;echo $BASH_SUBSHELL)</div>

<p>bash shell程序可使用命令行选项修改shell启动方式，以下为bash中可用的命令行参数</p>
<div class="table">

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c string</td>
<td>从string中读取命令并进行处理</td>
</tr>
<tr>
<td>-i</td>
<td>启动一个能够接收用户输入的交互shell</td>
</tr>
<tr>
<td>-l</td>
<td>以登录shell的形式启动</td>
</tr>
<tr>
<td>-r</td>
<td>启动一个受限shell，用户会被限制在默认目录中</td>
</tr>
<tr>
<td>-s</td>
<td>从标准输入中读取命令</td>
</tr>
</tbody></table>
</div>

<h5 id="父子shell的使用场景"><a href="#父子shell的使用场景" class="headerlink" title="父子shell的使用场景"></a>父子shell的使用场景</h5><p>如果命令或脚本需要在一个纯净的隔离环境下执行，或者希望执行某个操作但不改变当前的shell环境，创建子shell十分有用，但需要注意创建子shell带来的资源占用问题</p>
<div class="show">1.前往tmp目录并创建一个新文件，但不切换当前目录
(cd /tmp && touch newfile) #不会切换当前父shell的工作目录
2. 临时更改环境变量，使子shell在某个新的环境变量下工作，但不影响父shell
(export PATH=/custom/path && test.sh)
3. 通过( )创建多个子shell时，这些子shell会被依次创建，只有执行完第一个子shell中的任务，才会创建第二个
如：创建文件test.sh并写入以下命令
(sleep 3)  # 3 seconds
(sleep 2)  # 2 seconds
(sleep 1)  # 1 second
使用time()函数计算脚本执行时间
time(bash test.sh) #大约需要6s
但通过&创建子shell，这些任务会被放入后台，子shell会并行创建并执行
如：将文件test.sh修改为
sleep 3 &  # 3 seconds
sleep 2 &  # 2 seconds
sleep 1 &  # 1 second
wait
然后计算执行时间
time(bash test.sh) #大约需要3s，取决于执行时间最长的子shell
</div>



<h3 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，又被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中，可以使用<span class="tips">which</span>或<span class="tips">type -a</span>命令找到命令位置。执行外部命令时，会创建一个该命令对应的子进程，相对于内建命令来说，外部命令需要花费时间和资源来设置新子进程的环境</p>
<div class="shell"># which ps
/bin/ps</div>

<h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令不需要使用子进程来执行，它们已经和shell编译成了一体，在执行时速度更快，消耗的资源更少。常见的内建命令有<span class="tips">cd、echo、pwd、history、alias、continue、exit、jobs、kill</span>等</p>
<p>可以使用<span class="tips">type</span>命令来查看某个命令是否为内建命令</p>
<div class="shell"># type cd
cd is a shell builtin
</div>

<p>有些命令有多种实现方式，如：echo和pwd既有内建命令又有外部命令，默认使用内建命令，如果需要使用外部命令，则指定命令的具体路径即可。可以用<span class="tips">type -a</span>命令查看命令的不同实现</p>
<div class="shell"># type -a echo 
echo is a shell builtin 
echo is /bin/echo</div>

<h4 id="命令的执行优先级"><a href="#命令的执行优先级" class="headerlink" title="命令的执行优先级"></a>命令的执行优先级</h4><ul>
<li>第一顺位执行通过绝对路径或相对路径执行的命令</li>
<li>第二顺位执行自定义的命令别名</li>
<li>第三顺位执行bash内部命令</li>
<li>第四顺位执行$PATH环境变量定义的第一个命令</li>
</ul>
<h4 id="命令分组执行"><a href="#命令分组执行" class="headerlink" title="命令分组执行"></a>命令分组执行</h4><p>可以在一行中指定多个命令，命令之间使用分号(;)分隔，称为<span class="tips">命令列表</span>，这些命令会依次执行</p>
<div class="show">$ pwd ; ls ; cd /etc ; pwd ; ls</div>

<p>可以使用大括号或小括号将这些命令组合在一起，以便在特定情况(如在if-then语句中)一起执行，这称之为<span class="tips">命令分组</span>，主要有两种不同的命令分组：</p>
<ul>
<li><p>使用大括号{ }将多个命令组合在一起，可以在当前shell环境中执行，该方法也可用于shell脚本中if-then语句的结构控制</p>
<div class="show">{ pwd ; cd /etc ; ls }</div></li>
<li><p>如果将命令列表写在括号里，则shell会创建一个子shell执行这些命令，称为<span class="tips">进程列表</span>，这样可以使用多个子shell进行多进程处理</p>
<div class="show">创建1个子shell，输出值为1
(pwd ; ls ; cd /etc ; pwd ; ls ; echo $BASH_SUBSHELL)
括号可以嵌套，创建多个子shell进行多进程处理，创建了2个子shell(父shell创建子shell，子shell又创建了它的子shell)，输出值为2
( pwd ; (echo $BASH_SUBSHELL))
</div></li>
</ul>
<h4 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h4><p>shell中的协程用于在后台创建一个子shell，并在该shell中执行命令，其实就相当于使用&amp;将命令置入后台模式，但其特点在于我们可以为该协程命名，并且该协程创建时会自动创建一个匿名管道，并将子shell的输入输出重定向到这个管道，实现在 Bash 脚本中并发地执行子进程，并与该子进程进行双向数据通信的功能</p>
<p>协程的创建需要使用命令<span class="tips">coproc</span>，其语法为：</p>
<p><span class="strong">coproc 协程名 { 命令1; 命令2; }</span></p>
<p>如果不指定协程名，则默认为COPROC，之后命令会被置入后台模式，返回后台作业号和进程ID</p>
<div class="show">coproc my_process { echo "子进程开始"; sleep 2; echo "子进程执行完毕"; }
# 读取子进程的输出
while read -u "${my_process[0]}" output; do
    echo "父进程获得子进程输出: $output"
done
wait # 等待后台进程结束
echo "父进程执行完毕"</div>


<h3 id="Bash的内建命令"><a href="#Bash的内建命令" class="headerlink" title="Bash的内建命令"></a>Bash的内建命令</h3><h4 id="Bash的启动方式"><a href="#Bash的启动方式" class="headerlink" title="Bash的启动方式"></a>Bash的启动方式</h4><p><span class="strong">bash [选项] [脚本文件] [参数]</span></p>
<ul>
<li>-c “字符串”:执行字符串中的命令</li>
<li>-i 启动交互式bash</li>
<li>-l 或–login:模拟登录Shell，加载用户环境配置(如/etc/profile、~/.bash_profile等文件)</li>
<li>-s 从标准输入读取命令，通常结合管道和重定向符传递脚本内容</li>
<li>-r 以受限模式(Restricted Shell)启动bash，限制用户操作，用户将无法执行以下操作：<blockquote>
<blockquote>
<ul>
<li>使用cd命令改变当前目录</li>
<li>设置或更改 $PATH, $SHELL, $ENV, $BASH_ENV 等变量</li>
<li>使用 exec 执行其他程序</li>
<li>使用重定向 &gt;、&gt;&gt; 等创建/改写文件</li>
<li>调用包含 / 的命令（如 /bin/ls）</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>-v 逐行显示每一行命令(不将变量替换为值)，然后执行，通常用来观察脚本的执行流程</li>
<li>-x 逐行显示每一行命令，并将命令中的变量替换为实际值，输出的命令行首会添加+前缀，通常用来调试变量、参数值是否正确</li>
<li>-n 检查语法错误但不执行，仅验证脚本语法正确性</li>
<li>-e 严格模式，遇到错误立即退出，防止错误蔓延</li>
<li>-u 遇到未定义变量时报错，检查是否有未定义变量</li>
</ul>
<h4 id="history历史命令"><a href="#history历史命令" class="headerlink" title="history历史命令"></a>history历史命令</h4><p>在bash中执行过的命令会被缓存在内存中，方便重复调用，当shell退出或用户登出时会被写到用户对应的<span class="tips">.bash_history</span>历史命令记录文件中</p>
<p><span class="strong">history [选项] [历史命令保存文件]</span>查看使用过的命令，可以在后面加一个值指定显示n条命令</p>
<ul>
<li>-c 清空历史命令</li>
<li>-w 把缓存的历史命令写入历史命令保存文件~/.bash_history中</li>
<li>-a 将缓存的历史命令追加到历史命令保存文件中</li>
<li>-d 值 删除该条历史命令记录</li>
<li>-s 字符串  将该字符串添加到当前会话的命令历史中，但不执行</li>
</ul>
<div class="broadcast color-yellow">
<div class="iconfont icon-dengpao14hao"></div>
每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div>

<h5 id="调用历史命令"><a href="#调用历史命令" class="headerlink" title="调用历史命令"></a>调用历史命令</h5><ul>
<li><span class="strong">可通过上下箭头调用之前执行的命令</span></li>
<li><span class="strong">!!</span>再次执行上一次执行的命令</li>
<li><span class="strong">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)</li>
<li><span class="strong">!字符串</span>再次执行最后一次以该字符串开头的命令</li>
</ul>
<h4 id="alias自定义命令名"><a href="#alias自定义命令名" class="headerlink" title="alias自定义命令名"></a>alias自定义命令名</h4><p><span class="strong">alias</span>查看所有自定义的命令</p>
<p><span class="strong">alias 别名=’原命令’</span>自定义命令名，原命令依旧可用</p>
<p>使用命令定义的命令名只能临时生效，且只在当前shell中生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class="tips">/用户名/.bashrc</span>中</p>
<p>删除自定义的命令:</p>
<p><span class="strong">unalias 别名</span></p>
<h4 id="type查询命令类型"><a href="#type查询命令类型" class="headerlink" title="type查询命令类型"></a>type查询命令类型</h4><p>查看所指定的命令是shell 内建命令、外部可执行文件，还是其他类型</p>
<p><span class="strong">type [选项] 命令</span></p>
<ul>
<li>-a 查看所有可能的命令类型，有的命令可能同时有shell内建、外部二进制文件、用户别名等多种类型，该选项会列出所有情况</li>
<li>-t 只显示命令类型，而不显示命令路径，返回类型可能有：alias(别名)、builtin(内建命令)、file(外部命令)、function(定义的函数)、keyword(shell保留的关键字)</li>
<li>-p (小写)只显示命令路径，如果命令是shell内建命令或别名，使用此选项不会有输出</li>
<li>-P (大写)在PATH中查找该命令，无论该命令是何种类型，都返回其路径，该选项常被用来在shell脚本中查询并精确执行某命令，如$(type -P curl)</li>
<li>-f 不在shell函数中查找，即不将命令视为函数来查找</li>
</ul>
<h4 id="command执行原始命令"><a href="#command执行原始命令" class="headerlink" title="command执行原始命令"></a>command执行原始命令</h4><p>当系统中创建了alias别名和shell函数时，如果用户不想执行这些别名或shell函数，可以使用command来执行原始的Linux命令，常用来在脚本中安全地执行某个命令，而不受用户环境影响</p>
<p><span class="strong">command [选项] 命令 [参数]</span></p>
<ul>
<li>默认情况下，通过command执行的命令会无视alias或shell函数，执行系统原装的命令，默认前往PATH路径下查找该命令，包括用户自行在PATH中添加的路径</li>
<li>-p 在PATH中查找命令时，无视用户添加的PATH路径，而只在系统默认的PATH路径下查找(通常是/bin和/usr/bin等系统默认命令路径)，以免用户在PATH中添加了非系统原生的命令路径</li>
<li>-v 显示关于命令的信息(是别名、函数、内置命令还是磁盘上的可执行文件)，常用来在脚本中测试是否安装了某个命令，相较于使用type -P检测，command -v是POSIX标准，更推荐在可移植脚本中使用</li>
<li>-V 显示更详细的命令描述信息</li>
</ul>
<div class="show">1.command可以绕开alias和shell中定义的函数，
如：ls命令通常是以下命令别名
alias ls='ls --color=auto'
为了避免不同用户定义了不同ls命令别名，可以选择用command来规避这些影响
command ls  # 这将执行原始的ls命令，而不带--color=auto选项
2.通过command -v检测某个命令是否存在
<code> if command -v apt &>/dev/null; then
    sudo apt install -y .......
  elif command -v yum &>/dev/null; then
    sudo yum install -y .......
  elif command -v dnf &>/dev/null; then
    sudo dnf install -y .......
  else
    echo "不支持当前包管理器安装"
  fi</code>
</div>


<h4 id="set管理shell功能"><a href="#set管理shell功能" class="headerlink" title="set管理shell功能"></a>set管理shell功能</h4><p>set命令用来查看或修改当前shell的设置，如打开或关闭shell的调试、安全、错误处理等功能，修改shell的位置变量等，它的功能十分强大，这里只整理部分可能用到的常用功能</p>
<p><span class="strong">set [-或+] [选项] [-&zwnj;-] [参数]</span></p>
<ul>
<li>不添加任何选项和参数时，set会打印所有shell变量和函数，包括环境变量、用户定义变量、位置参数、全局函数等</li>
<li>当为set不提供任何选项，只提供参数时，set会将位置参数$1,$2..设置为对应参数</li>
<li><span class="strong">-</span>会开启一个功能选项，<span class="strong">+</span>会关闭一个选项<blockquote>
<blockquote>
<ul>
<li>e 一旦任何命令返回非0状态，立刻退出脚本</li>
<li>v 逐行显示每一行命令(不将变量替换为值)，然后执行</li>
<li>x 逐行显示每一行命令，并将命令中的变量替换为实际值，输出的命令行首会添加+前缀</li>
<li>u 使用未定义变量时报错</li>
<li>n 只做语法检查不执行脚本</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>[-/+o 特殊控制名] 开启或关闭特殊设置<blockquote>
<blockquote>
<ul>
<li>history：启用命令历史记录，对于交互式shell，该配置默认开启</li>
<li>ignoreeof：交互式shell在读取到EOF时不会退出</li>
<li>pipefail：管道中任意命令失败时，整个管道视为失败</li>
<li>vi：使用vi风格的编辑界面，这会影响用于read -e 的编辑界面</li>
<li>emacs：使用emacs风格的编辑界面，这会影响用于read -e 的编辑界面</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<div class="show">1.set可以用来修改位置参数
set -&zwnj;- 10 20 30
set会将$1、$2、$3设置为10，20，30
set -&zwnj;- 
echo "参数个数：$#"
set会将所有位置参数设置为unset，即清空它们
$1,$2..会被清空，$#参数个数为0
2.set命令可以在脚本中临时开启某些调试功能，方便调试某一段代码
这可以视为bash -vxu命令的局部版本，只在某一段代码中开启这些功能
#!/bin/bash
echo "开始"
set -x    #开启x选项的功能，逐行显示命令和变量值
echo "调试这句"
name="Alice"
echo "你好，$name"
set +x    #关闭x选项的功能
echo "结束"
3.在脚本开头添加<soan class="text-red">set -euo pipefail</soan>，用来开启严格模式
之后，脚本中任意命令失败都会退出脚本
使用未定义的变量时报错
管道中任意命令失败时，整个管道视为失败
</div>

<h4 id="空操作"><a href="#空操作" class="headerlink" title=":空操作"></a>:空操作</h4><p>不执行任何操作，总是返回成功(退出状态码为0)，一般可用作占位符</p>
<div class="show">1.可用作条件语句中的占位符
if 条件; then
    :       #占位符，不执行任何操作
else
    echo "Not true"
fi
2.在某些旧脚本中可用来隐藏输出
: $(command)
将command命令输出结果传参给:
而:命令本身无输出，因此上述语句等价于command > /dev/null
</div>

<h4 id="mapfile将标准输入存储到数组"><a href="#mapfile将标准输入存储到数组" class="headerlink" title="mapfile将标准输入存储到数组"></a>mapfile将标准输入存储到数组</h4><p>该用于将输入(如文件或管道数据)逐行读取到数组中，该命令的效率高于while read循环</p>
<p><span class="strong">mapfile [选项] [数组名]</span></p>
<ul>
<li>从标准输入或文件中读取行数组中，如果未指定数组，则使用默认的数组名MAPFILE</li>
<li>-d “行终止符”：指定每个行的终止符，而不是默认的换行符，-d “”指定空字符串，将使用NUL作为行终止符</li>
<li>-n 值N：只输入N行，如果值为0将输入所有行到数组</li>
<li>-u 文件描述符：从该文件描述符指向的文件读取数据</li>
<li>-O 索引值：指定索引值，从该值开始存储，默认从0存储</li>
<li>-s 值N：跳过前N行，不存储到数组</li>
<li>-t 输入时删除行尾的行终止符</li>
<li>-C 回调函数名：在每次读入行时执行回调函数，回调函数中可以使用$1(下一个存入的数组索引)，$2(要存入的行内容)引用对应的数据，mapfile命令会自动传递这2个参数，如果不指定-c，默认每5000行执行一次回调，以避免性能问题</li>
<li>-c 值N：和-C选项搭配使用，每读取N行执行一次回调</li>
</ul>
<div class="show">1.默认情况，mapfile会将每行的换行符也作为数组元素，因此往往需要-t删除换行符
mapfile -t arr < file.txt
2.指定回调函数时，可以用$1和$2引用数组索引和值，索引会随着-O选项的值产生偏移
<code>arr=(aaaa bbbbb)
process_line() &#123;
    echo "下一个索引: $1" #依次输出3，4
&#125;
mapfile -t -O 3 -c 1 -C process_line arr &lt;&lt;EOF
hello
shell
EOF
</code></div>

<h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>exec命令的主要功能有两个</p>
<h5 id="替换当前shell进程"><a href="#替换当前shell进程" class="headerlink" title="替换当前shell进程"></a>替换当前shell进程</h5><div class="api-block">exec [选项] 执行命令</div>

<ul>
<li>-c 清除所有环境变量(除了HOME、SHELL、PATH、TERM、MAIL、USER和LOGNAM)</li>
<li>-l 启动一个新shell执行对应的命令，该shell以登录shell的身份工作</li>
</ul>
<p>当使用exec命令执行命令或可执行文件时，新执行的程序会替换当前的shell进程。exec命令会将指定的命令或程序加载到当前shell进程的内存空间中，并替换 shell 进程的执行上下文，包括内存代码段、数据段、堆栈中的数据等，同时，新进程会继承原进程的大部分环境和信息，包括进程PID、环境变量、当前工作目录、打开的文件描述符、用户和用户组ID、进程优先级、以及对进程的资源限制(如内存限制、文件大小限制)等信息，这样可以在不创建新进程的情况下，执行新的功能和程序，极大程度上节省了用于创建新进程消耗的系统资源，可以有效减少进程数量并简化进程管理。</p>
<p>该命令可用于在不创建新进程或子shell的情况下切换shell并替换当前的shell进程，通过exec命令切换，Linux会保持shell的PID、用户和用户组ID、当前工作目录等环境不变，也不会创建子shell消耗更多的系统资源</p>
<div class="show">e.g.从bash切换到sh
exec /bin/sh
</div>

<p>该命令也可以用其他程序替换当前的shell进程，例如，在脚本的最后一行使用 exec 来启动一个长期运行的程序，当脚本即将运行结束，shell的使命也即将完成，通过exec命令让新的程序替换shell进程，而不再需要创建新的进程，可以有效节约系统资源</p>
<div class="show">#!/bin/bash
# 通过shell执行脚本功能
# 即将运行结束，让新进程替换shell进程
exec /path/to/long_running_application
</div>

<p>此外，exec命令还被用于以下场景：</p>
<ul>
<li>当某个进程认为自己不能再为系统和用户作出任何贡献时，就可以调用exec命令让新的进程替代自己，如：一些守护进程，或用于系统初始化启动的进程，当系统完成启动，这些进程的使命已经完成，exec命令可以使新进程接管自己的初始化环境，减少进程间的通信和数据拷贝，提高系统性能</li>
<li>在一些特定环境中，使用exec命令可以保证某个关键任务完全接管当前进程，而不会有多余的 shell 进程存在</li>
<li>可以用于动态加载新程序和脚本，在其环境不变的情况下执行新脚本，而无需额外创建进程</li>
<li>在某些需要严格控制权限的环境中，用 exec 替换当前进程可以确保新的进程继承当前进程的所有权限和环境，使进程在受限的环境中启动并继承了相应权限</li>
</ul>
<div class="broadcast color-red">
<div class="iconfont icon-gantanhao"></div>
注意！如果使用远程终端在登录shell中使用exec命令，如：执行 exec ls -l，ls命令会替换当前shell进程，这会导致远程shell会话终止，远程连接断开。因此如果要在远程连接时执行该命令，最好在子shell中使用，在登录shell中使用会导致ssh连接断开</div>


<h5 id="修改文件描述符"><a href="#修改文件描述符" class="headerlink" title="修改文件描述符"></a>修改文件描述符</h5><div class="api-block">exec 重定向命令</div>

<p>exec 命令还可以用来重定向文件描述符。在这种用法中，exec 并不会替换当前的 shell 进程，而是会替换脚本的执行环境，该命令可用来重定向整个脚本的标准输入输出文件，或者关闭不需要的文件描述符</p>
<div class="show">e.g.将脚本的所有标准输出信息重定向到out.txt文件
exec 1&gt;out.txt
e.g.关闭文件描述符3
exec 3&gt;&-
</div>

<h3 id="lt-与-gt-重定向"><a href="#lt-与-gt-重定向" class="headerlink" title="&lt;()与&gt;()重定向"></a>&lt;()与&gt;()重定向</h3><p><span class="tips">&lt;(命令)</span>和<span class="tips">&gt;(命令)</span>是Bash特有的进程替换（Process Substitution）语法，用于将命令的输入或输出“伪装”为一个文件路径，以供其他命令使用。</p>
<p>使用时，Bash会创建一个临时文件描述符，然后将该文件名作为参数传入命令，该语法适合一些需要文件名或路径作为参数的命令中，如：cat、diff、read、tar等</p>
<div class="show">1.diff需要文件路径作为输入
diff <(sort file1.txt) <(sort file2.txt)
2.结合mapfile将命令结果存入数组
mapfile -t arr < <(find /dst -mindepth 1 -maxdepth 1 -type d)
3.处理输出
tail -f server.log > >(grep "ERROR" > errors.txt)
</div>


<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符(Wildcard)是shell中用来进行文件或路径匹配的操作符，常用ls、cp、rm等命令，它的功能和正则表达式(Regular Expression)很像，但本质上是不同的工具</p>
<h4 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h4><div class="table">

<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意长度的任意字符，可以为空</td>
</tr>
<tr>
<td>?</td>
<td>匹配单个任意字符</td>
</tr>
<tr>
<td>[abc]</td>
<td>匹配a或b或c中的任意一个字符，相当于”或”</td>
</tr>
<tr>
<td>[!abc]或[^abc]</td>
<td>匹配不包括a、b、c在内的任意一个字符，相当于”非”</td>
</tr>
</tbody></table>
</div>

<div class="show">1.*可以代表任意数量的字符，包括空
ls file*.txt
会列出file.txt以及file后还有其他字符的文件
fileA.txt  file20201205.txt
2.?代表单个任意字符，?可多写代表多个任意字符
file?.txt匹配如：fileA.txt
file????.txt匹配file2021.txt
3.[xxx]代表关系或
file[ABC].txt
匹配
fileA.txt fileB.txt fileC.txt
4.[!xxx]代表关系非
file[!BC].txt
匹配
fileA.txt，但不包括 fileB.txt fileC.txt
</div>

<h4 id="花括号扩展"><a href="#花括号扩展" class="headerlink" title="{..}花括号扩展"></a>{..}花括号扩展</h4><p>花括号符<span class="tips">{..}</span>可以扩展花括号中的值，通常需要和其他字符串搭配，用来快速和其他字符串生成组合值，该语法为Bash独有，大多数shell不支持</p>
<div class="table">

<table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>{a,b,c}</td>
<td>将a,b,c扩展到其他字符串中</td>
</tr>
<tr>
<td>{1..4}或{a..z}</td>
<td>将该区间的所有值或字母拓展到其他字符串中</td>
</tr>
</tbody></table>
</div>

<div class="show">1.创建3个文件dir_A，dir_B，dir_C
mkdir dir_{A,B,C}
2.移除file.txt和file.log
rm -f file.{txt,log}
3.创建5个文件file_1,file_2,file_3,file_4,file_5
touch file_{1..5}
4.执行一个循环
for i in {1..6};do
        echo $i
done
5.file[abc]和file{a,b,c}的行为不同
file[abc]代表filea或fileb或filec
file{a,b,c}代表filea、fileb、filec，是"与"的关系
[]通常用来校验或查询是否有该文件
{}通常用来创建或移除已有文件
</div>

<h4 id="扩展通配符"><a href="#扩展通配符" class="headerlink" title="扩展通配符"></a>扩展通配符</h4><p>扩展通配符需要先执行<span class="tips">shopt -s extglob</span>来启用extglob扩展模式</p>
<div class="table">

<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>?(pattern)</td>
<td>匹配0次或1次 pattern</td>
<td>file?(.bak) 匹配 file 或 file.bak</td>
</tr>
<tr>
<td>*(pattern)</td>
<td>匹配0次或多次 pattern</td>
<td>dir*(/tmp) 匹配 dir、dir/tmp、dir/tmp/tmp…</td>
</tr>
<tr>
<td>+(pattern)</td>
<td>匹配1次或多次 pattern</td>
<td>log+(.old) 匹配 log.old、log.old.old…</td>
</tr>
<tr>
<td>@(pattern1|pattern2)</td>
<td>匹配 pattern1 或 pattern2</td>
<td>file@(.txt|.csv) 匹配 file.txt 或 file.csv</td>
</tr>
<tr>
<td>!(pattern)</td>
<td>匹配 不符合 pattern 的内容</td>
<td>!(*.bak) 匹配所有非 .bak 文件</td>
</tr>
</tbody></table>
</div>

<h3 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h3><p>POSIX标准预定义了一些常用的字符类，方便在处理字符串、文件名等情况时直接调用，在grep、sed、awk等Linux命令中，这些预定义的字符类需要在<span class="tips">[ ]</span>中使用，在tr等命令中则可以直接使用</p>
<div class="table">

<table>
<thead>
<tr>
<th>通配符</th>
<th>匹配的范围</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>匹配字母或数字</td>
<td>[a-zA-Z0-9]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配字母</td>
<td>[a-zA-Z]</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配数字</td>
<td>[0-9]</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配小写字母</td>
<td>[a-z]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配大写字母</td>
<td>[A-Z]</td>
</tr>
<tr>
<td>[:space:]</td>
<td>空白字符</td>
<td>空格、\t、\n等</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表符</td>
<td>空格和\t</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
<td>!@#$%^&amp;*()等</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>可见字符</td>
<td>非空白、非控制字符</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可打印字符</td>
<td>包括空格在内的可打印字符</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>控制字符</td>
<td>ASCII 0-31 和 127</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制数字字符</td>
<td>[0-9A-Fa-f]</td>
</tr>
</tbody></table>
</div>

<div class="show">1.在ls等命令中匹配文件名
匹配file1.txt或fileaaa.txt等字母或数字结尾的文件
ls file[[:alnum:]].txt
匹配以字母开头的文件
ls [[:alpha:]]* 
2.在grep命令中匹配字符
grep '[[:digit:]]' file.txt    # 匹配数字
3.通过sed和awk处理字符串
sed 's/[[:space:]]//g' file    # 删除空白字符
awk '/[[:alpha:]]/{print}'     # 打印包含字母的行
4. 在Shell的[[ =~ ]]中进行正则匹配
if [[ "A" =~ [[:upper:]] ]]; then echo "大写字母"; fi
5. tr命令不需要嵌套[ ]
echo "hello world" |tr '[:lower:]' '[:upper:]' #小写转大写
</div>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>bash shell使用环境变量(environment variable)来存储有关shell的会话和工作环境，并将这些信息存储在内存中，以便程序或shell脚本能够轻松访问到这些数据，一般情况下，环境变量均使用大写的变量名</p>
<h4 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h4><p>全局环境变量该shell和其创建的子shell中均有效，以下为查询全局环境变量的命令</p>
<ul>
<li><span class="strong">printenv</span>查看所有全局环境变量<blockquote>
<blockquote>
<ul>
<li>-0 每行输出末尾输出空字符(null)，而不是换行符，以便其他程序解析输出</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><span class="strong">env</span>查看所有全局环境变量</li>
<li><span class="strong">printenv 变量名</span>查看指定环境变量</li>
<li><span class="strong">echo $变量名</span>查看指定环境变量</li>
</ul>
<p>定义全局环境变量需要使用export关键字</p>
<ul>
<li><span class="strong">export 变量名=值</span>&emsp;定义全局环境变量</li>
<li><span class="strong">unset 变量名</span>&emsp;删除变量</li>
</ul>
<p>父shell中创建的全局环境变量在子shell中也有效，且如果此时在子shell中修改该变量的值，不会影响其在父shell中的值，修改后的值只在子shell中有效</p>
<div class="show">e.g.定义一个普通全局变量，在子shll中修改值，然后返回父shell读取值
$ my_variable="I am Global now" 
$ export my_variable #声明为全局变量
$ bash   #切换到子shell
$ echo $my_variable #子shell可以访问该变量
I am Global now
$ my_variable="Null"  #在子shell中修改变量值
$ export my_variable  #即便用export命令也无法修改其在父shell中的值
$ echo $my_variable 
Null  #该值在子shell中有效
$ exit 
exit 
$ 
$ echo $my_variable #父shell中值不变
I am Global now
</div>

<div class="show">e.g.环境变量支持数组
myArray=(one two three four five)
echo ${myArray[2]}
echo ${myArray[*]}
unset myArray #删除数组
</div>

<h4 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h4><p>局部环境变量只能在定义它们的shell中有效，父shell中的局部环境变量无法在子shell中访问到。Linux中没有只显示局部环境变量的命令，但可以通过<span class="strong">set</span>命令查看所有环境变量，包括局部变量、全局变量以及用户定义变量</p>
<p>定义局部环境变量的方法和定义局部自定义变量的方法一样，不需要加export关键字，只需要将变量名大写用于识别该变量是一个环境变量即可</p>
<div class="show">MY_PORT=2021
echo $MY_PORT
bash #切换到子shell
echo $MY_PORT  #无法访问该变量</div>

<h4 id="Bash中的环境变量"><a href="#Bash中的环境变量" class="headerlink" title="Bash中的环境变量"></a>Bash中的环境变量</h4><p>以下为bash shell种已经定义好的环境变量，可以直接调用，有些环境变量的值为空，因此执行set命令时不一定会列出所有变量</p>
<div class="table">

<table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HOME</td>
<td>当前用户的主目录</td>
</tr>
<tr>
<td>UID</td>
<td>当前用户的真实用户ID（数字形式）</td>
</tr>
<tr>
<td>EUID</td>
<td>当前用户的有效用户ID（数字形式）</td>
</tr>
<tr>
<td>IFS</td>
<td>shell用来将文本字符串分割成字段的一系列字符</td>
</tr>
<tr>
<td>MAIL</td>
<td>当前用户收件箱的文件名</td>
</tr>
<tr>
<td>MAILPATH</td>
<td>冒号分隔的当前用户收件箱的文件名列表</td>
</tr>
<tr>
<td>OPTARG</td>
<td>getopts命令处理的最后一个选项参数值</td>
</tr>
<tr>
<td>OPTIND</td>
<td>getopts命令处理的最后一个选项参数的索引号</td>
</tr>
<tr>
<td>PATH</td>
<td>shell查找命令的目录列表，由冒号分隔</td>
</tr>
<tr>
<td>PS1</td>
<td>shell命令行界面的主提示符</td>
</tr>
<tr>
<td>PS2</td>
<td>shell命令行界面的次提示符</td>
</tr>
<tr>
<td>CDPATH</td>
<td>cd命令的搜索路径，切换路径时，cd命令会先尝试在当前目录下查找指定目录并切换过去，如果当前目录下并没有指定的目录，则cd命令会前往该变量设置的路径下查找并切换，可以指定多个路径用冒号分隔</td>
</tr>
<tr>
<td>BASH</td>
<td>当前shell实例的全路径名</td>
</tr>
<tr>
<td>BASH_ALIASES</td>
<td>含有当前已设置别名的关联数组</td>
</tr>
<tr>
<td>BASH_ARGC</td>
<td>含有传入子函数或shell脚本的参数总数的数组变量</td>
</tr>
<tr>
<td>BASH_ARCV</td>
<td>含有传入子函数或shell脚本的参数的数组变量</td>
</tr>
<tr>
<td>BASH_CMDS</td>
<td>关联数组，包含shell执行过的命令的所在位置</td>
</tr>
<tr>
<td>BASH_COMMAND</td>
<td>shell正在执行的命令或马上就执行的命令</td>
</tr>
<tr>
<td>BASH_ENV</td>
<td>设置了的话，bash脚本会在执行前读取变量中的文件，读取文件中设置的变量，并执行其中的命令</td>
</tr>
<tr>
<td>BASH_EXECUTION_STRING</td>
<td>使用bash -c选项传递过来的命令</td>
</tr>
<tr>
<td>BASH_LINENO</td>
<td>含有当前执行的shell函数的源代码行号的数组变量</td>
</tr>
<tr>
<td>BASH_REMATCH</td>
<td>只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive match）时，包含了匹配到的模式和子模式</td>
</tr>
<tr>
<td>BASH_SOURCE</td>
<td>含有当前正在执行的shell函数所在源文件名的数组变量</td>
</tr>
<tr>
<td>BASH_SUBSHELL</td>
<td>当前子shell环境的嵌套级别（初始值是0）</td>
</tr>
<tr>
<td>BASH_VERSINFO</td>
<td>含有当前运行的bash shell的主版本号和次版本号的数组变量</td>
</tr>
<tr>
<td>BASH_VERSION</td>
<td>当前运行的bash shell的版本号</td>
</tr>
<tr>
<td>BASH_XTRACEFD</td>
<td>若设置成了有效的文件描述符（0、1、2），则’set -x’调试选项生成的跟踪输出，可被重定向。通常用来将跟踪输出到一个文件中</td>
</tr>
<tr>
<td>BASHOPTS</td>
<td>当前启用的bash shell选项的列表</td>
</tr>
<tr>
<td>BASHPID</td>
<td>当前bash进程的PID</td>
</tr>
<tr>
<td>COLUMNS</td>
<td>当前bash shell实例所用终端的宽度</td>
</tr>
<tr>
<td>COMP_CWORD</td>
<td>COMP_WORDS变量的索引值，后者含有当前光标的位置</td>
</tr>
<tr>
<td>COMP_LINE</td>
<td>当前命令行</td>
</tr>
<tr>
<td>COMP_POINT</td>
<td>当前光标位置相对于当前命令起始的索引</td>
</tr>
<tr>
<td>COMP_KEY</td>
<td>用来调用shell函数补全功能的最后一个键</td>
</tr>
<tr>
<td>COMP_TYPE</td>
<td>一个整数值，表示所尝试的补全类型，用以完成shell函数补全</td>
</tr>
<tr>
<td>COMP_WORDBREAKS</td>
<td>Readline库中用于单词补全的词分隔字符</td>
</tr>
<tr>
<td>COMP_WORDS</td>
<td>含有当前命令行所有单词的数组变量</td>
</tr>
<tr>
<td>COMPREPLY</td>
<td>含有由shell函数生成的可能填充代码的数组变量</td>
</tr>
<tr>
<td>COPROC</td>
<td>占用未命名的协进程的I/O文件描述符的数组变量</td>
</tr>
<tr>
<td>DIRSTACK</td>
<td>含有目录栈当前内容的数组变量</td>
</tr>
<tr>
<td>EMACS</td>
<td>设置为’t’时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止</td>
</tr>
<tr>
<td>ENV</td>
<td>如果设置了该环境变量，在bash shell运行之前会读取该变量指定路径中的文件，如果未设置，Bash 会默认读取用户的”HOME/.bashrc”文件以设置环境变量，该变量方便用户自定义bash启动时的环境变量(仅用于当bash shell以POSIX模式被调用时)</td>
</tr>
<tr>
<td>FCEDIT</td>
<td>供fc命令使用的默认编辑器</td>
</tr>
<tr>
<td>FIGNORE</td>
<td>在进行文件名补全时可以忽略后缀名列表，由冒号分隔</td>
</tr>
<tr>
<td>FUNCNAME</td>
<td>当前执行的shell函数的名称</td>
</tr>
<tr>
<td>FUNCNEST</td>
<td>当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止）</td>
</tr>
<tr>
<td>GLOBIGNORE</td>
<td>冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名</td>
</tr>
<tr>
<td>GROUPS</td>
<td>含有当前用户属组列表的数组变量</td>
</tr>
<tr>
<td>histchars</td>
<td>控制历史记录扩展，最多可有3个字符</td>
</tr>
<tr>
<td>HISTCMD</td>
<td>当前命令在历史记录中的编号</td>
</tr>
<tr>
<td>HISTCONTROL</td>
<td>控制哪些命令留在历史记录列表中</td>
</tr>
<tr>
<td>HISTFILE</td>
<td>保存shell历史记录列表的文件名(默认是.bash_history)</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>最多在历史文件中存多少行</td>
</tr>
<tr>
<td>HISTTIMEFORMAT</td>
<td>如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳</td>
</tr>
<tr>
<td>HISTIGNORE</td>
<td>由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>最多在历史文件中存多少条命令</td>
</tr>
<tr>
<td>HOSTFILE</td>
<td>shell在补全主机名时读取的文件名称</td>
</tr>
<tr>
<td>HOSTNAME</td>
<td>当前主机的名称</td>
</tr>
<tr>
<td>HOSTTYPE</td>
<td>当前运行bash shell的机器</td>
</tr>
<tr>
<td>IGNOREEOF</td>
<td>shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1）</td>
</tr>
<tr>
<td>INPUTRC</td>
<td>Readline初始化文件名（默认是.inputrc）</td>
</tr>
<tr>
<td>LANG</td>
<td>shell的语言环境类别</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>定义了一个语言环境类别，能够覆盖LANG变量</td>
</tr>
<tr>
<td>LC_COLLATE</td>
<td>设置对字符串排序时用的排序规则</td>
</tr>
<tr>
<td>LC_CTYPE</td>
<td>决定如何解释出现在文件名扩展和模式匹配中的字符</td>
</tr>
<tr>
<td>LC_MESSAGES</td>
<td>在解释前面带有$的双引号字符串时，该环境变量决定了所采用的语言环境设置</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>决定着格式化数字时采用的语言环境设置</td>
</tr>
<tr>
<td>LINENO</td>
<td>当前执行的脚本的行号</td>
</tr>
<tr>
<td>LINES</td>
<td>定义了终端上可见的行数</td>
</tr>
<tr>
<td>MACHTYPE</td>
<td>按“CPU-公司-系统”（CPU-company-system）格式定义的系统类型</td>
</tr>
<tr>
<td>MAPFILE</td>
<td>一个数组变量，当mapfile命令未指定数组变量作为参数时，它存储了mapfile所读入的文本</td>
</tr>
<tr>
<td>MAILCHECK</td>
<td>shell查看新邮件的频率（以秒为单位，默认值是60）</td>
</tr>
<tr>
<td>OLDPWD</td>
<td>shell之前的工作目录</td>
</tr>
<tr>
<td>OPTERR</td>
<td>设置为1时，bash shell会显示getopts命令产生的错误</td>
</tr>
<tr>
<td>OSTYPE</td>
<td>定义了shell所在的操作系统</td>
</tr>
<tr>
<td>PIPESTATUS</td>
<td>含有前台进程的退出状态列表的数组变量</td>
</tr>
<tr>
<td>POSIXLY_CORRECT</td>
<td>设置了的话，bash会以POSIX模式启动</td>
</tr>
<tr>
<td>PPID</td>
<td>bash shell父进程的PID</td>
</tr>
<tr>
<td>PROMPT_COMMAND</td>
<td>设置了的话，在命令行主提示符显示之前会执行这条命令</td>
</tr>
<tr>
<td>PROMPT_DIRTRIM</td>
<td>用来定义当启用了\w或\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换</td>
</tr>
<tr>
<td>PS3</td>
<td>select命令的提示符</td>
</tr>
<tr>
<td>PS4</td>
<td>如果使用了bash的-x选项，在命令行之前显示的提示信息</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作目录</td>
</tr>
<tr>
<td>RANDOM</td>
<td>返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子）</td>
</tr>
<tr>
<td>READLINE_LINE</td>
<td>当使用bind –x命令时，存储Readline缓冲区的内容</td>
</tr>
<tr>
<td>READLINE_POINT</td>
<td>当使用bind –x命令时，表示Readline缓冲区内容插入点的当前位置</td>
</tr>
<tr>
<td>REPLY</td>
<td>read命令的默认变量</td>
</tr>
<tr>
<td>SECONDS</td>
<td>自从shell启动到现在的秒数（对其赋值将会重置计数器）</td>
</tr>
<tr>
<td>SHELL</td>
<td>bash shell的全路径名</td>
</tr>
<tr>
<td>SHELLOPTS</td>
<td>已启用bash shell选项列表，列表项之间以冒号分隔</td>
</tr>
<tr>
<td>SHLVL</td>
<td>shell的层级；每次启动一个新bash shell，该值增加1</td>
</tr>
<tr>
<td>TIMEFORMAT</td>
<td>指定了shell的时间显示格式</td>
</tr>
<tr>
<td>TMOUT</td>
<td>select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示无限长</td>
</tr>
<tr>
<td>TMPDIR</td>
<td>目录名，保存bash shell创建的临时文件</td>
</tr>
</tbody></table>
</div>

<h4 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h4><p>用户登录shell时，shell程序会读取环境变量配置文件作为初始化环境，用户可以修改这些文件来指定shell启动时自动执行的任务，以及指定一些环境变量值</p>
<h5 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h5><p>对所有用户生效</p>
<ul>
<li><strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件，用于保存全局环境变量和shell参数，并调用其他配置文件</li>
<li><strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用</li>
<li><strong>/etc/bashrc</strong>&emsp;用于保存bash相关的全局环境变量、函数、命令别名，如PS1等bash终端的环境</li>
</ul>
<p>/etc/profile配置文件是最主要的配置文件，其中几个常见变量的作用：</p>
<div class="table">

<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>当前用户</td>
</tr>
<tr>
<td>LOGNAME</td>
<td>当前用户名，配置文件中LOGNAME=$USER，因此同USER</td>
</tr>
<tr>
<td>MAIL</td>
<td>用户邮箱</td>
</tr>
<tr>
<td>HOSTNAME</td>
<td>主机名</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>历史命令保存条数</td>
</tr>
<tr>
<td>umask</td>
<td>设置文件默认权限</td>
</tr>
</tbody></table>
</div>

<h5 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h5><p>只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件</p>
<ul>
<li>$HOME/.bash_profile &emsp; 用户个人的/etc/profile文件，保存用户自定义的环境变量，该文件会在用户登录时读取，且一般会在文件中调用其他配置文件(如下面的.bashrc)</li>
<li>$HOME/.bashrc &emsp;写有用户自定义的命令别名、函数等，该文件会在打开一个新的交互式bash时都读取一次</li>
<li>$HOME/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等</li>
<li>$HOME/.bash_history &emsp;记录用户执行过的命令</li>
</ul>
<p>部分Linux发行版还可能会提供如：$HOME/.bash_login、$HOME/.profile等文件，其作用一般和$HOME/.bash_profile一样，shell一般会优先执行$HOME/.bash_profile</p>
<h5 id="不重启就使配置文件生效"><a href="#不重启就使配置文件生效" class="headerlink" title="不重启就使配置文件生效"></a>不重启就使配置文件生效</h5><p>直接执行任一命令</p>
<ul>
<li><span class="strong">source 文件名</span></li>
<li><span class="strong">.配置文件名</span></li>
</ul>
<h4 id="不同启动方式读取的配置文件"><a href="#不同启动方式读取的配置文件" class="headerlink" title="不同启动方式读取的配置文件"></a>不同启动方式读取的配置文件</h4><p>日常使用时，启动bash一般分为3种方式，每种方式都会读取不同的配置文件</p>
<ol>
<li>登录用户账户时作为默认启动的交互式shell</li>
<li>通过bash等命令切换创建的非登录交互式子shell</li>
<li>执行脚本或任务启动的非交互式shell，如：执行脚本、使用at、cron等命令后台执行定时任务、通过脚本或()等方式启动的子shell</li>
</ol>
<p>作为默认登录shell启动时，bash会依次读取全局/etc/profile文件，以及用户的$HOME/.bash_profile文件，而绝大多数Linux发行版用户$HOME/.bash_profile文件会调用$HOME/.bashrc文件，而$HOME/.bashrc文件又会调用/etc/bashrc文件，因此一般情况下，登录shell会依次加载<span class="tips">/etc/profile、$HOME/.bash_profile、$HOME/.bashrc、/etc/bashrc</span>文件</p>
<p>而作为非登录(但交互式)shell启动时，bash不会访问/etc/profile、$HOME/.bash_profile等文件，只会读取<span class="tips">$HOME/.bashrc</span>文件，而绝大部分Linux发行版$HOME/.bashrc文件通常包含了对/etc/bashrc的调用，因此它会依次读取<span class="tips">$HOME/.bashrc、/etc/bashrc</span>文件。由于非登录shell是从父shell启动的，因此/etc/profile、$HOME/.bash_profile文件中的全局环境变量也会从父shell中继承下来。</p>
<p>作为非交互式shell启动时，bash shell会检查<span class="tips">BASH_ENV</span> 环境变量，如果该变量指定了文件，shell会执行该文件里的命令，并读取里面设置的变量。但在绝大多数Linux发行版中，这个变量一般为空，因此非交互式shell一般不会读取配置文件。但该方式启动的shell，若脚本直接将当前shell作为脚本的执行shell，则所有当前shell中已加载的局部变量和全局变量，都可以在脚本中使用。如果脚本中通过诸如进程列表等方式创建了子shell，而其父shell在其加载的/etc/profile、$HOME/.bashrc等(具体加载哪些文件取决于该父shell的启动方式)文件中使用export声明了全局变量，用于执行脚本的子shell会继承这些变量。</p>
<h4 id="环境变量的持久化"><a href="#环境变量的持久化" class="headerlink" title="环境变量的持久化"></a>环境变量的持久化</h4><p>通过赋值方式创建的变量保持于内存中，如果退出shell这些变量会失效，可以将这些环境变量写于配置文件中实现变量的持久化。</p>
<p>对于所有用户都可能用到的环境变量，尽量避免将全局的环境变量放在<span class="tips">/etc/profile</span>文件中，该文件会在系统升级时被覆盖，可以在<span class="tips">/etc/profile.d</span>目录中创建一个.sh结尾的文件，将全局环境变量放在该文件中，然后再在profile文件中加载该目录下的内容。</p>
<p>对于个人用户，可以将环境变量存放于<span class="tips">$HOME/.bashrc</span>文件中，但注意，如果需要在脚本中调用某些自定义环境变量，由于脚本启动的一般是非交互式shell，所以需要先检查是否设置了<span class="tips">BASH_ENV</span> 环境变量，如果有则需要将环境变量存放在对应的文件中；如果没有，则考虑在其父shell会读取的文件中将环境变量声明为export或在脚本中设置一个新的。</p>
<h3 id="终端控制"><a href="#终端控制" class="headerlink" title="终端控制"></a>终端控制</h3><h4 id="ANSI转义字符序列"><a href="#ANSI转义字符序列" class="headerlink" title="ANSI转义字符序列"></a>ANSI转义字符序列</h4><!-- 为了控制终端的显示和行为，ANSI 标准定义了一系列用于控制终端输出选项的字符序列，称为 ANSI 转义序列（Escape Sequences），其中包括了常见的控制字符（Control Characters）。这些控制字符通常分为 C0 控制字符和 C1 控制字符。ASCII 码表中 0 到 31 之间的字符称为 C0 控制字符，用于基本的终端控制。但原有的控制字符功能并不全面，因此，为了实现更多的终端控制功能，ASCII 码表扩展出了以 ESC 字符（\x1b）开头的控制序列，包括 C1 控制字符（ASCII 码表 128-159）。C1 控制字符被广泛应用于控制光标、屏幕和字符渲染。这部分控制序列中的常见类型称为 CSI（Control Sequence Introducer），而 Bash 也使用这些控制序列来控制终端行为 -->

<p>为了控制终端的显示和行为，ANSI标准定义了一系列用于控制终端输出选项的字符序列，称为ANSI转义字符序列(Escape Sequence)。这些转义字符序列中ASCII码表0到31(0x00–0x1F)之间的字符称为C0控制字符，C0字符通常用于基本的文本控制和终端操作，如：回车(CR)、换行(LF)、制表符(TAB)等。由于原有的控制字符功能不够全面，为了实现更多的终端控制功能，ASCII码表扩展出了值在128-159(0x80–0x9F)之间的C1控制字符，C1控制字符提供了更多扩展的高级控制功能，包括光标控制、颜色设置、字符集切换、设备控制等</p>
<h4 id="CSI序列"><a href="#CSI序列" class="headerlink" title="CSI序列"></a>CSI序列</h4><p>C1控制字符中用于控制光标、设置文本样式和颜色以及实现屏幕的清除、局部刷新等操作的控制字符称为<span class="tips">CSI</span>(Control Sequence Introducer)字符，CSI字符序列以<span class="tips">ESC</span>(\x1b)开头，并紧接一个<span class="tips">[</span>(代表CSI)，将ESC转换为ASCII码后，控制字符在代码中常写为<span class="tips">\e[</span>或<span class="tips">\x1b[</span>或<span class="tips">\033[</span>，完整的CSI控制语句为：<br><span class="text-red" style="margin:0">\e[</span><span class="text-green" style="margin:0">参数1;参数2;参数3…</span><span class="text-blue" style="margin:0">函数名</span></p>
<ul>
<li>\e[ 为转义字符引导头</li>
<li>中间参数部分可以由0个或多个数字组成，多个数字间用分号分隔</li>
<li>函数名为需要调用的CSI函数功能名称</li>
</ul>
<div class="show">如：<span class="strong">\e[0;4;34m</span>
# \e[ 为转义字符引导头
# m为函数名
# 0;4;34为函数参数，相当于 m(0,4,34)
</div>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>CSI提供了很多用于光标控制、屏幕控制、字符渲染的函数</p>
<h5 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h5><div class="table">

<table>
<thead>
<tr>
<th>函数</th>
<th>举例</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>\e[nA</td>
<td>光标上移n行(默认1)</td>
</tr>
<tr>
<td>B</td>
<td>\e[nB</td>
<td>光标下移n行(默认1)</td>
</tr>
<tr>
<td>C</td>
<td>\e[nC</td>
<td>光标左移n行(默认1)</td>
</tr>
<tr>
<td>D</td>
<td>\e[nD</td>
<td>光标右移n行(默认1)</td>
</tr>
<tr>
<td>E</td>
<td>\e[nE</td>
<td>光标下移n行(默认1)，非标准</td>
</tr>
<tr>
<td>F</td>
<td>\e[nF</td>
<td>光标上移n行(默认1)，非标准</td>
</tr>
<tr>
<td>G</td>
<td>\e[nG</td>
<td>光标移动至当前行的n列，非标准</td>
</tr>
<tr>
<td>H</td>
<td>\e[x;yH</td>
<td>光标移动到x行y列</td>
</tr>
<tr>
<td>s</td>
<td>\e[s</td>
<td>保存光标位置</td>
</tr>
<tr>
<td>u</td>
<td>\e[u</td>
<td>取出光标位置</td>
</tr>
<tr>
<td>l</td>
<td>\e[?25l</td>
<td>隐藏光标</td>
</tr>
<tr>
<td>h</td>
<td>\e[?25h</td>
<td>显示光标</td>
</tr>
</tbody></table>
</div>

<h5 id="屏幕控制"><a href="#屏幕控制" class="headerlink" title="屏幕控制"></a>屏幕控制</h5><div class="table">

<table>
<thead>
<tr>
<th>函数</th>
<th>举例</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>J</td>
<td>\e[nJ</td>
<td>清除指定范围内的屏幕，0为光标位置到屏幕末尾，1为光标位置到屏幕开头，2为全屏幕</td>
</tr>
<tr>
<td>K</td>
<td>\e[nK</td>
<td>清除该行的指定范围，0为光标到行尾，1为光标至行头，2为整行</td>
</tr>
<tr>
<td>S</td>
<td>\e[nS</td>
<td>整页向上滚动n行，非标准</td>
</tr>
<tr>
<td>T</td>
<td>\e[nT</td>
<td>整页向下滚动n行，非标准</td>
</tr>
</tbody></table>
</div>

<h4 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h4><p>终端中最为常用的转义序列还是用于修改终端字体颜色、背景颜色和显示效果的函数和参数，即SGR(Set graphics mode)函数<span class="tips">m</span>，常用于配合echo语句输出不同样式的提示信息，修改终端样式的转义字符序列一般为：<br><span class="strong">\e[参数m</span></p>
<p>在指定多个参数时，转义字符序列通常为：<br><span class="strong">\e[<span class="text-red" style="margin:0">字体样式;</span><span class="text-green" style="margin:0">字体颜色;</span><span class="text-blue" style="margin:0">背景色</span>m</span></p>
<p>参数不分先后顺序，指定多个同类样式时，后面的样式将覆盖前面的样式(如：指定多个背景色，只有最后一个背景色会生效)</p>
<div class="show">1.输出红色字符串 "RedColor"
echo -e "\e[31mRedColor \e[0m"
2.输出高亮、红色字体、背景为淡黄色的字符串"aaa"
echo -e "\e[1;31;103maaaa\e[0m"
# 末尾的\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性
# \e可替换为\033或\x1B
</div>

<h5 id="恢复默认"><a href="#恢复默认" class="headerlink" title="恢复默认"></a>恢复默认</h5><p><span class="strong">\e[0m</span>表示取消所有设置的属性(包括颜色、加粗、闪烁等效果)，使后续输出内容恢复默认属性</p>
<h5 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h5><div class="table">

<table>
<thead>
<tr>
<th>设置效果代码</th>
<th>效果</th>
<th>取消效果代码</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>加粗高亮</td>
<td>21</td>
</tr>
<tr>
<td>2</td>
<td>变暗(未被广泛支持)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>斜体(未被广泛支持)</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>下划线</td>
<td>24</td>
</tr>
<tr>
<td>5</td>
<td>缓慢闪烁,低于每分钟150次</td>
<td>25</td>
</tr>
<tr>
<td>6</td>
<td>快速闪烁，每分钟150次以上(未被广泛支持)</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>反转背景色和前景色</td>
<td>27</td>
</tr>
<tr>
<td>8</td>
<td>隐藏，常用于密码(未被广泛支持)</td>
<td>28</td>
</tr>
<tr>
<td>9</td>
<td>划掉文字(未被广泛支持)</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>默认字体</td>
<td></td>
</tr>
<tr>
<td>11-19</td>
<td>替代字体</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>尖角体</td>
<td></td>
</tr>
</tbody></table>
</div>


<h5 id="字体颜色-前景色"><a href="#字体颜色-前景色" class="headerlink" title="字体颜色(前景色)"></a>字体颜色(前景色)</h5><p>以下颜色在不同终端中被定义了不同的RGB值，且没有一个通用标准，因此不同终端中的样式可能有所不同，详情可参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">ANSI escape code</a></p>
<div class="table">

<table>
<thead>
<tr>
<th>代码</th>
<th>颜色</th>
<th>代码</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>39</td>
<td>默认颜色</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>黑色</td>
<td>90</td>
<td><span style="color:rgb(128,128,128)">灰色</span></td>
</tr>
<tr>
<td>31</td>
<td><span style="color:rgb(170,0,0)">红色</span></td>
<td>91</td>
<td><span style="color:rgb(255,0,0)">亮红色</span></td>
</tr>
<tr>
<td>32</td>
<td><span style="color:rgb(0,170,0)">绿色</span></td>
<td>92</td>
<td><span style="color:rgb(0,255,0)">亮绿色</span></td>
</tr>
<tr>
<td>33</td>
<td><span style="color:rgb(255,199,6)">黄色</span></td>
<td>93</td>
<td><span style="color:rgb(255,255,0)">亮黄色</span></td>
</tr>
<tr>
<td>34</td>
<td><span style="color:rgb(0,0,238)">蓝色</span></td>
<td>94</td>
<td><span style="color:rgb(59,120,255)">亮蓝色</span></td>
</tr>
<tr>
<td>35</td>
<td><span style="color:rgb(205,0,205)">品红</span></td>
<td>95</td>
<td><span style="color:rgb(255,0,255)">亮品红色</span></td>
</tr>
<tr>
<td>36</td>
<td><span style="color:rgb(0,205,205)">青色</span></td>
<td>96</td>
<td><span style="color:rgb(0,255,255)">亮青色</span></td>
</tr>
<tr>
<td>37</td>
<td><span style="color:rgb(204,204,204)">白色</span></td>
<td>97</td>
<td>亮白色</td>
</tr>
</tbody></table>
</div>

<h5 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h5><p>每一个颜色都和上面相同，只是他们将作为背景色使用</p>
<div class="table">

<table>
<thead>
<tr>
<th>代码</th>
<th>颜色</th>
<th>代码</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>49</td>
<td>默认颜色</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>黑色</td>
<td>100</td>
<td>灰色</td>
</tr>
<tr>
<td>41</td>
<td>红色</td>
<td>101</td>
<td>亮红色</td>
</tr>
<tr>
<td>42</td>
<td>绿色</td>
<td>102</td>
<td>亮绿色</td>
</tr>
<tr>
<td>43</td>
<td>黄色</td>
<td>103</td>
<td>亮黄色</td>
</tr>
<tr>
<td>44</td>
<td>蓝色</td>
<td>104</td>
<td>亮蓝色</td>
</tr>
<tr>
<td>45</td>
<td>品红</td>
<td>105</td>
<td>亮品红色</td>
</tr>
<tr>
<td>46</td>
<td>青色</td>
<td>106</td>
<td>亮青色</td>
</tr>
<tr>
<td>47</td>
<td>白色</td>
<td>107</td>
<td>亮白色</td>
</tr>
</tbody></table>
</div>

<h5 id="修改文件目录颜色"><a href="#修改文件目录颜色" class="headerlink" title="修改文件目录颜色"></a>修改文件目录颜色</h5><p>想在使用ls命令后使各种不同类型文件显示不同颜色，参考dircolors命令</p>
<h4 id="OSC序列"><a href="#OSC序列" class="headerlink" title="OSC序列"></a>OSC序列</h4><p>OSC(Operating System Command)是一类用于执行操作系统级别命令的控制序列，通常用来设置终端标题，或与系统剪贴板进行交互等。OSC和CSI都是ANSI转义序列的一部分，其中CSI是C1控制字符集的一部分，而OSC是独立的多字符集合，不属于C1控制字符集</p>
<p>与CSI字符序列语法类似，OSC序列也是以<span class="tips">ESC</span>开头，随后，OSC序列后紧接一个<span class="tips">]</span>，后接一个数字标识符，然后是一个命令或参数，最后以<span class="tips">\a</span>(BEL)或<span class="tips">\e\</span>(ESC+\)结尾，完整的OSC语法为：<br><span class="text-red" style="margin:0">\e]</span><span class="text-blue" style="margin:0">函数标识值;</span><span class="text-green" style="margin:0">参数1;参数2;参数3…</span><span class="text-red" style="margin:0">\a</span></p>
<ul>
<li>\e]是OSC控制序列的引导头</li>
<li>函数值功能参考下表</li>
<li>\a 标识控制序列结束</li>
</ul>
<h4 id="OSC函数值"><a href="#OSC函数值" class="headerlink" title="OSC函数值"></a>OSC函数值</h4><p>OSC字符序列也可以修改终端的文本颜色，背景色等样式，与CSI不同的是，OSC字符序列控制的是全局的终端样式，而CSI序列只修改跟随在CSI后的文本样式，而不会修改已经输出完毕的文本样式。但OSC在一些终端中(尤其远程终端中)只支持修改终端窗口的标题等，而不支持修改光标、文本颜色等样式</p>
<div class="table">

<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>更改窗口标题和标签栏标题</td>
</tr>
<tr>
<td>1</td>
<td>设置终端窗口的图标名</td>
</tr>
<tr>
<td>2</td>
<td>仅更改窗口标题</td>
</tr>
<tr>
<td>10</td>
<td>更改字体颜色(前景色)</td>
</tr>
<tr>
<td>11</td>
<td>更改背景色</td>
</tr>
<tr>
<td>12</td>
<td>更改光标颜色</td>
</tr>
<tr>
<td>52</td>
<td>将文本写入剪贴板</td>
</tr>
<tr>
<td>104</td>
<td>重置所有颜色</td>
</tr>
</tbody></table>
</div>

<div class="show">以下OSC序列只会临时修改终端设置，在命令执行完毕后可能会立即恢复终端默认样式，以至于无法查看到样式变化，如果需要通过OSC长久修改终端标题等设置，请修改<span class="tips">PS1</span>变量的值
1.更改窗口标题和标签栏标题
echo -e "\e]0;新标题\a"
2. 仅更改窗口标题
echo -e "\e]2;新的窗口标题\a"
3.更改字体颜色为#00ff00
echo -e "\e]10;#00ff00\a"
4.更改光标颜色为#ff00ff
echo -e "\e]12;#ff00ff\a"
</div>

<h4 id="修改命令提示符"><a href="#修改命令提示符" class="headerlink" title="修改命令提示符"></a>修改命令提示符</h4><p>默认情况下的命令提示符通常为<span class="tips">[用户名@主机名 当前目录]主提示符</span>(不同Linux发行版可能有所不同)，如：[root@localhost etc]#，该默认值由系统定义的变量<span class="tips">PS1</span>决定，可通过<span class="strong">echo $PS1</span>&emsp;查看当前配置，也可以通过修改PS1变量自定义命令提示符，如：</p>
<div class="show">PS1='[\u@\t \w]#'
命令提示符将修改为：
[root@15:21:13 /home/user1]#
</div>

<p>通过修改PS1变量自定义的命令提示符，只在本次登录有效，系统重启后将失效，需要永久修改命令提示符，可以将上述语句写入配置文件<span class="tips">/etc/bashrc</span>中，若只想修改某个用户的终端，可以修改该用户家目录下的<span class="tips">.bashrc</span>配置文件中的PS1变量，修改完后可以使用<span class="tips">source 文件名</span>命令重新加载配置文件，使配置立即生效</p>
<h6 id="修改命令提示符文本颜色"><a href="#修改命令提示符文本颜色" class="headerlink" title="修改命令提示符文本颜色"></a>修改命令提示符文本颜色</h6><p>修改命令提示符文本颜色时，PS1变量值中的CSI语法需要使用<span class="tips">[ ]</span>进行包裹，并且”[ ]”需要使用转义字符进行转义，避免bash解析其中的语法，即语法为：</p>
<p><span class="strong">\[\e[颜色码m\]</span></p>
<div class="shell">如在/etc/bashrc文件最后一行添加语句：
PS1='\[\e[0m\][\[\e[36m\]\u\[\e[34m\]@\h \[\e[36m\]\W\[\e[0m\]]\[\e[95m\]#\[\e[0m\]'
终端提示符将变为：
[<span style="color:#0cf8fc;">root</span><span style="color:#0c8afc;">@myLinux</span> <span style="color:#0cf8fc;">etc</span>]<span style="color:#fc0ce6;">#</span>
</div>

<p>以下是自定义命令提示符时常用的转义字符：</p>
<div class="table">

<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\u</td>
<td>显示当前用户名</td>
</tr>
<tr>
<td>\h</td>
<td>显示简写主机名(不包含域名，该值来自<span class="tips">/etc/hostname</span>文件)</td>
</tr>
<tr>
<td>\H</td>
<td>显示完整的主机名(通常包括域名)</td>
</tr>
<tr>
<td>\w</td>
<td>显示当前所在路径的完整名称</td>
</tr>
<tr>
<td>\W</td>
<td>显示当前所在目录(路径的最后一个路径段)</td>
</tr>
<tr>
<td>\#</td>
<td>显示本次会话已经执行的命令个数</td>
</tr>
<tr>
<td>\$</td>
<td>显示命令主提示符，root用户提示符为”#”，普通用户为”$”</td>
</tr>
<tr>
<td>\d</td>
<td>显示当前系统日期，格式为”星期 月 日”</td>
</tr>
<tr>
<td>\t</td>
<td>显示24小时制时间，格式为”HH:MM:SS”</td>
</tr>
<tr>
<td>\T</td>
<td>显示12小时制时间，格式为”HH:MM:SS”</td>
</tr>
<tr>
<td>\A</td>
<td>显示24小时制时间，格式为”HH:MM”</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\[ 和 \]</td>
<td>用于定义非打印字符的开始和结束(主要用于设置颜色，避免光标定位错误)</td>
</tr>
</tbody></table>
</div>

<h4 id="终端标题"><a href="#终端标题" class="headerlink" title="终端标题"></a>终端标题</h4><p>虽然<span class="tips">PS1</span>主要用于控制终端的命令提示符，但我们可以在PS1中嵌入OSC转义序列来控制终端的标题。与CSI类似，PS1变量值中的OSC序列也需要使用<span class="tips">[ ]</span>进行包裹，并且”[ ]”需要使用转义字符进行转义，避免bash解析其中的语法</p>
<div class="show">1.某个debian发行版的默认PS1值
PS1="\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$"
其中：
\[\e]0;\u@\h: \w\a\]为OSC序列，定义终端标题
${debian_chroot:+($debian_chroot)}用于在命令提示符中提示用户当前是否处于chroot环境
2.修改终端标题
PS1='\[\e]0;终端标题\a\]\t@debian\$'
</div>

<div class="broadcast color-red">
<div class="iconfont icon-gantanhao"></div>
PS1的字符串值请用单引号或双引号包裹，否则可能出现Bash解析错误的情况</div>

<h4 id="本地终端登录前的欢迎信息"><a href="#本地终端登录前的欢迎信息" class="headerlink" title="本地终端登录前的欢迎信息"></a>本地终端登录前的欢迎信息</h4><p>需要修改本地终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue</span>，配置文件中可使用的转义字符：</p>
<div class="table">

<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前系统日期</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前系统时间</td>
</tr>
<tr>
<td>\s</td>
<td>显示操作系统名称</td>
</tr>
<tr>
<td>\l</td>
<td>显示登录的终端号</td>
</tr>
<tr>
<td>\m</td>
<td>显示硬件架构信息，如i386等</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机名</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示内核版本</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前用户登录的序列号</td>
</tr>
</tbody></table>
</div>

<div class="show">最小化安装的Centos7默认配置通常为：
\S
Kernel \r on an \m
</div>

<h4 id="远程终端登录前的欢迎信息"><a href="#远程终端登录前的欢迎信息" class="headerlink" title="远程终端登录前的欢迎信息"></a>远程终端登录前的欢迎信息</h4><p>修改远程终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue.net</span>，该文件不支持上述本地终端登录可用的转义字符，需要显示此欢迎信息，需要在配置文件<span class="tips">/etc/ssh/sshd_config</span>中加入<span class="tips">Banner /etc/issue.net</span>配置内容(需要重启生效)</p>
<div class="shell">/etc/ssh/sshd_config文件添加配置位置:
#UseLogin no
#UsePrivilegeSeparation sandbox
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#ShowPatchLevel no
#UseDNS yes
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

<p># no default banner path<br>#Banner none<br><span style="color:rgb(232, 250, 0)">Banner</span><span style="color:rgb(250, 0, 136);"> /etc/issue.net</span></p>
<p># Accept locale-related environment variables</div></p>
<h4 id="终端登录成功后的提示信息"><a href="#终端登录成功后的提示信息" class="headerlink" title="终端登录成功后的提示信息"></a>终端登录成功后的提示信息</h4><p>配置文件位于<span class="tips">/etc/motd</span>(Message of the Day文件)，用于在远程和本地终端登录成功后显示提示信息，文件通常默认为空</p>
<p>在ubuntu中，登录提示文本MOTD通常是动态生成的，配置文件位于<span class="tips">/etc/update-motd.d/</span>中，包含一系列脚本，这些脚本会生成系统信息（如负载、内存使用等）并在登录时显示，脚本名前的数字表示脚本执行顺序，相同数字的脚本会按照脚本名字母顺序依次执行，执行顺序也决定了这些文本的显示顺序</p>
<div class="show">update-motd.d目录下可能会有以下脚本文件：
00-header
10-help-text
....
91-release-upgrade
98-fsck-at-reboot
如果需要自定义提示信息，可以在该目录下新建一个脚本，如：
1. 创建一个脚本 99-custom
2. 添加需要打印的信息
<code>#!/bin/sh
echo "欢迎使用shiwivi的 Ubuntu 服务器！"</code>
3. 给脚本添加可执行权限
sudo chmod +x /etc/update-motd.d/99-custom
<span class="tips">如果不想显示某个脚本的内容，可以通过修改文件名（例如在文件名中添加 .disabled）来禁用特定脚本，或者修改脚本中的输出语句</span>
</div>

<h3 id="tput-终端控制标准化接口"><a href="#tput-终端控制标准化接口" class="headerlink" title="tput 终端控制标准化接口"></a>tput 终端控制标准化接口</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="Terminfo数据库"><a href="#Terminfo数据库" class="headerlink" title="Terminfo数据库"></a>Terminfo数据库</h5><p>Terminfo数据库是Unix/Linux 系统中用于描述终端能力的标准化数据库，为各种终端提供统一的描述方式，将终端功能映射为标准名称，使应用程序无需关心具体终端差异即可用统一接口(tput)控制终端，这种设计使得Unix/Linux系统能够支持数千种不同的终端类型</p>
<p>标准 Terminfo 数据库通常位于以下位置:</p>
<ul>
<li>/usr/share/terminfo/ </li>
<li>/lib/terminfo/</li>
</ul>
<p>这些目录中可能包含上百种不同的终端配置，它们根据终端名首字母被整理到了1-9a-Z不同目录下，如：/usr/share/terminfo/x/目录下包含了xterm等常用X window相关终端的配置，每个终端类型在 Terminfo 数据库中都有一个独立的编译文件，该编译文件保存了终端支持的行数、列数、颜色、控制序列等终端属性</p>
<h5 id="tput命令工具"><a href="#tput命令工具" class="headerlink" title="tput命令工具"></a>tput命令工具</h5><p>tput是一个用于终端控制的工具，作为terminfo数据库的前端，它能根据terminfo数据库提供一种标准化的方式来查询和修改终端的行为，tput抽象了不同终端之间的差异，为开发者提供了统一的控制接口</p>
<p>调用tput命令时，tput会首先检查<span class="tips">TERM</span>环境变量来确定当前终端类型，然后从terminfo数据库中查找对应的终端配置。当执行tput命令时，它会将用户请求的能力名称（如setaf表示设置前景色）转换为该终端类型实际支持的控制序列，tput将转换后的控制序列输出到标准输出，这些序列会被终端解释并执行相应的操作</p>
<h5 id="与CSI控制序列的区别"><a href="#与CSI控制序列的区别" class="headerlink" title="与CSI控制序列的区别"></a>与CSI控制序列的区别</h5><p>CSI控制序列是直接将控制字符包含在输出的字符串中，字节流不经任何处理直接交由终端处理，由终端内置解析器负责实时解释执行。CSI控制序列有以下特点：</p>
<ul>
<li>控制序列包含在输出序列中，简单高效，适合快速输出</li>
<li>同一段控制序列，不同终端的解析可能不同，行为不一致，甚至可能出现因为终端不支持而出现乱码等情况。</li>
<li>CSI序列可能会被滥用于终端注入攻击</li>
</ul>
<p>tput工作时，是先读取<span class="tips">TERM</span>环境变量确定终端类型，然后根据<code>/usr/share/terminfo</code>目录对应终端的配置编译文件，将终端控制请求转换为目标终端的专用序列，以达到动态翻译的效果。它有以下特点：</p>
<ul>
<li>控制序列动态生成，需要tput程序介入处理</li>
<li>自动处理不同终端的实现差异，以保证行为一致，当某一个控制效果终端不支持时，tput会在序列生成阶段，回退到默认样式或终止操作，它能在跨平台脚本中提供更健壮的功能</li>
<li>没有CSI注入风险</li>
</ul>
<h4 id="tput命令"><a href="#tput命令" class="headerlink" title="tput命令"></a>tput命令</h4><p><span class="strong">tput [选项] [terminfo功能名称] [参数]</span></p>
<ul>
<li>-T终端类型:手动指定一个终端类型用于查阅或操作，默认情况下tput会从<span class="tips">TERM</span>环境变量获取当前终端类型</li>
<li>-V 查看当前版本</li>
<li>-S &gt;&gt;标准输入：指定多个终端功能，此时需要从标准输入指定这些功能，而不再从命令行中指定，每行只能指定一个终端功能</li>
</ul>
<h4 id="基本terminfo功能"><a href="#基本terminfo功能" class="headerlink" title="基本terminfo功能"></a>基本terminfo功能</h4><ul>
<li><span class="strong">tput init </span> 初始化终端，重新加载终端的配置信息，常用于终端设置被修改时，恢复终端的默认配置</li>
<li><span class="strong">tput clear</span> 清空屏幕，将光标移动到左上角，在多数系统中，clear命令会在底层调用tput clear</li>
<li><span class="strong">tput reset</span> 重置终端，清空屏幕，并且重置终端的光标位置、回显位置(echo、print等命令输出位置)、键盘映射等配置，常用于终端出现严重异常，恢复终端。在部分终端中，该命令会清空滚动缓冲区，即清空终端的历史命令输出内容</li>
<li><span class="strong">tput longname</span> 输出终端的完整名称</li>
</ul>
<div class="show">1.查看当前终端的完整名称
tput longname
xterm的输出：
xterm terminal emulator (X Window System)
2.查看指定终端的信息，以AT&T 5620终端为例
tput -T5620 longname
输出：
AT&T 5620 terminal 88 columns
</div>

<h4 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h4><p>常用终端类型<span class="tips">xterm</span>通常只支持8种(0-7颜色值)ANSI标准颜色(可以通过tput colors查看)，如果需要使用更多颜色，可以修改终端类型为<span class="tips">TERM=xterm-256color</span>，以支持256种颜色</p>
<ul>
<li><span class="strong">tput colors</span> 查看当前终端支持的颜色数量</li>
<li><span class="strong">tput setaf 颜色值N</span>设置终端前景色</li>
<li><span class="strong">tput setab 颜色值N</span>设置终端背景色</li>
<li><span class="strong">tput op</span>重置前景色和背景色为默认</li>
<li><span class="strong">tput sgr0</span>重置所有文字样式和颜色为默认</li>
</ul>
<p>部分常用颜色值</p>
<div class="table">

<table>
<thead>
<tr>
<th>编号</th>
<th>颜色</th>
<th>编号</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>黑色</td>
<td>8</td>
<td>灰色</td>
</tr>
<tr>
<td>1</td>
<td>红色</td>
<td>9</td>
<td>亮红色</td>
</tr>
<tr>
<td>2</td>
<td>绿色</td>
<td>10</td>
<td>亮绿色</td>
</tr>
<tr>
<td>3</td>
<td>黄色</td>
<td>11</td>
<td>亮黄色</td>
</tr>
<tr>
<td>4</td>
<td>蓝色</td>
<td>12</td>
<td>亮蓝色</td>
</tr>
<tr>
<td>5</td>
<td>品红</td>
<td>13</td>
<td>亮品红色</td>
</tr>
<tr>
<td>6</td>
<td>青色</td>
<td>14</td>
<td>亮青色</td>
</tr>
<tr>
<td>7</td>
<td>白色</td>
<td>15</td>
<td>亮白色</td>
</tr>
</tbody></table>
</div>

<h4 id="文字样式控制"><a href="#文字样式控制" class="headerlink" title="文字样式控制"></a>文字样式控制</h4><div class="table">

<table>
<thead>
<tr>
<th>功能名</th>
<th>作用</th>
<th>功能名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>bold</td>
<td>加粗</td>
<td>dim</td>
<td>淡化</td>
</tr>
<tr>
<td>smul</td>
<td>开启下划线</td>
<td>rmul</td>
<td>关闭下划线</td>
</tr>
<tr>
<td>rev</td>
<td>反显(前后景色交换)</td>
<td>blink</td>
<td>闪烁</td>
</tr>
<tr>
<td>smso</td>
<td>开启”突出模式”</td>
<td>rmso</td>
<td>关闭”突出模式”</td>
</tr>
<tr>
<td>invis</td>
<td>隐藏文字</td>
<td>sgr0</td>
<td>重置所有样式和颜色</td>
</tr>
</tbody></table>
</div>

<div class="show">shell编程中设置文字加粗与下划线
BOLD=$(tput bold)
UNDER=$(tput smul)
RESET=$(tput sgr0)
echo "${BOLD}${UNDER}加粗+下划线${RESET}"
</div>

<h4 id="光标控制-1"><a href="#光标控制-1" class="headerlink" title="光标控制"></a>光标控制</h4><p>注意，指定光标(行列)位置时，从0开始计算位置</p>
<ul>
<li>tput cols 获取终端列数(宽度)</li>
<li>tput lines 获取终端行数(高度)</li>
<li><span class="strong">tput home</span>将光标移动到左上角(0,0)</li>
<li><span class="strong">tput cup 行 列</span>将光标移到指定行列，行列从0开始计数</li>
<li><span class="strong">tput hpa 列</span>将光标移动到指定列</li>
<li><span class="strong">tput vpa 行</span>将光标移动到到指定行</li>
<li><span class="strong">tput ll</span>移动光标到最后一行第一列</li>
<li><span class="strong">tput sc</span>保存当前光标位置(部分终端可能不支持)</li>
<li><span class="strong">tput rc</span>恢复保存的终端位置(部分终端可能不支持)</li>
<li><span class="strong">tput civis</span>隐藏光标</li>
<li><span class="strong">tput cnorm</span>恢复光标显示</li>
</ul>
<p>模拟一个进度条</p>
<pre><code>#!/bin/bash

#初始化终端
tput civis #隐藏光标
tput sc    #保存光标位置

#配置颜色
red_color=$(tput setaf 1)
blue_color=$(tput setaf 4)
reset=$(tput sgr0)

#模拟进度条
for i in &#123;0..100&#125;;do

#计算进度条的"#"和空白部分，并缩减进度条长度到50字符
filled=$((i/2))     
empty=$((50-filled))

#下述命令printf "%0.s#" $(seq 1 $filled)中
#由于%0.s#部分限制参数输出宽度为0
#因此不会输出$(seq 1 $filled)的内容
#只会输出一个格式字符串中指定的"#"
#$(seq 1 $filled)会被展开
#命令解析为printf "%0.s#" 1 2 3...
#所有参数共用格式字符串"%0.s#"，每有一个参数，就会输出一个"#"
#因此$(seq 1 $filled)输出内容并不重要，它们只负责让printf输出一个#
#$(seq 1 $filled)只用来指定重复输出#的个数
#如果输出数量一定，printf "%0.s#" &#123;1..5&#125;也是类似的作用
bar=$(printf "%0.s#" $(seq 1 $filled)) #输出#
space=$(printf "%0.s " $(seq 1 $empty))#输出空白符

tput rc  #每次都从原光标位置开始打印进度条，以覆盖上次的进度条
echo -ne "$&#123;blue_color&#125;[$&#123;bar&#125;$&#123;space&#125;]$&#123;reset&#125; $&#123;red_color&#125;$&#123;i&#125;%$&#123;reset&#125;"
sleep 0.05
done

#结束打印
echo       #输出换行
tput cnorm #恢复光标显示
</code></pre>

<p>文字自动居中</p>
<pre><code>cols=$(tput cols)
msg="居中标题"
padding=$(( (cols - $&#123;#msg&#125;) / 2 ))
printf "%*s%s\n" "$padding" "" "$msg"
</code></pre>


<h4 id="擦除行"><a href="#擦除行" class="headerlink" title="擦除行"></a>擦除行</h4><ul>
<li>tput ed 擦除光标之后的所有行，仅保留光标之前的行</li>
<li>tput el 擦除当前行光标之后到行末的内容</li>
<li>tput el1 擦除当前行光标之前到行开头间的内容</li>
<li>tput el2 擦除整行</li>
</ul>
<h4 id="插入-删除行与列"><a href="#插入-删除行与列" class="headerlink" title="插入/删除行与列"></a>插入/删除行与列</h4><ul>
<li>tput il 插入一行，重排 UI</li>
<li>tput dl 删除一行，重排 UI</li>
<li>tput ich 在当前位置插入字符</li>
<li>tput dch 删除当前位置字符</li>
</ul>
<h4 id="切换屏幕缓冲区"><a href="#切换屏幕缓冲区" class="headerlink" title="切换屏幕缓冲区"></a>切换屏幕缓冲区</h4><p>实现类似less、top、vim等命令，独占整个屏幕，且命令结束返回原屏幕的效果</p>
<ul>
<li><span class="strong">tput smcup</span>切换到新屏幕</li>
<li><span class="strong">tput rmcup</span>切换回原屏幕</li>
</ul>

        </div>
    </div>
    <div class="post-nav">
        
            <div class="post-prev ">
                <a href="/blog/2021/12/29/Shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/">上一篇：Shell脚本语言</a>
            </div>
            
            
                <div class="post-next">
                    <a href="/blog/2021/12/29/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">下一篇：Linux常用工具命令 </a>
                </div>
                 
    </div>
    <div class="container">
        <!--设计来源于B站-季夏小贞-->
        <div class="big-head"></div>
        <div class="ears"></div>
        <div class="body"></div>
        <div class="paws-front"></div>
        <div class="paws-back"></div>
        <div class="details"></div>
        <div class="tail"></div>
        <div class="sleep">
          <span class="s1">z</span>
          <span class="s2">z</span>
          <span class="s3">z</span>
          <span class="s4">z</span>
          <span class="s5">z</span>
        </div>
    </div>
</div>
<div class="right-menu">
    <a class="iconfont back-top" href="javascript:">&#xe655;</a>
    <div class="husky"></div>
  </div>
</div>

<script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.bumpytext.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/highlightjs-line-numbers.min.js"></script>
<script src="/blog/js/article.js"></script>

</body></html>