<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="shiwi"><meta name="copyright" content="SHIWIVI"><link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon"><style>.preload{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;left:0;top:0;width:100%;height:100%;background-color:#000;z-index:100}.text{margin-bottom:10px;color:#00cff3;text-shadow:0 0 3px #00cff3;font-size:20px}.text span{display:inline-block}.dance{animation:dance .8s linear}.text span:nth-child(1){animation-delay:0s}.text span:nth-child(2){animation-delay:.1s}.text span:nth-child(3){animation-delay:.2s}.text span:nth-child(4){animation-delay:.3s}.text span:nth-child(5){animation-delay:.4s}.text span:nth-child(6){animation-delay:.5s}.text span:nth-child(7){animation-delay:.6s}.text span:nth-child(8){animation-delay:.7s}.text span:nth-child(9){animation-delay:.8s}.text span:nth-child(10){animation-delay:.9s}@keyframes dance{0%{transform:translateY(0)}50%{transform:translateY(-20px)}100%{transform:translateY(0)}}.loading{width:80%;max-width:260px;height:6px;background-color:#e1e4e8;border-radius:6px}.bar{display:flex;height:100%;background:linear-gradient(90deg,#ffd33d,#ea4aaa 10%,#b34bff 30%,#01feff 51%,#ffb33d 68%,#ea4aaa 85%,#b34bff);background-size:300% 100%;animation:bar 2s linear infinite}@keyframes bar{0%{background-position:100%}100%{background-position:0}}</style><body><div class="preload"><div class="text"><span>L</span> <span>o</span> <span>a</span> <span>d</span> <span>i</span> <span>n</span> <span>g</span> <span>.</span> <span>.</span> <span>.</span></div><div class="loading"><span class="bar"></span></div></div><script>let texts=document.querySelector('.text').querySelectorAll('span');let timer=setInterval(()=>{texts.forEach((item)=>{item.classList.toggle("dance")})},1700);window.onload=function(){clearInterval(timer);document.querySelector('.preload').style="display:none;"}</script><title>SHIWIVI-文章</title>
<link rel="stylesheet" href="https://at.alicdn.com/t/font_2856826_bu73u0ahu7a.css">

<link rel="stylesheet" href="/blog/css/index.css">
<link rel="stylesheet" href="/blog/css/article.css">
<link rel="stylesheet" href="/blog/css/atelier-cave.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="SHWIVI's blog" type="application/atom+xml">
</head>
<body>
<div class="nav">
    <div class="card">
        <div class="head">
            <img src="/blog/images/head.jpg"  alt="头不见了.." title="狗">
        </div>
        <div class="card-text">
            <p>(ー`´ー)</p>
            <p>那不是bug，是彩蛋</p>
        </div> 
    </div>
    <ul class="label">
        
        <li><a href="/blog/index.html">首页</a></li>
        
        <li><a href="/blog/life">日常</a></li>
        
        <li><a href="/blog/record">一句</a></li>
        
        <li><a href="/blog/message">留言</a></li>
        
        <li><a href="/blog/about">关于</a></li>
          
    </ul>
        <ul class="tag">
            <li><a href="/blog/tags/Command">#Command</a></li>
            <li><a href="/blog/tags/Java">#Java</a></li>
            <li><a href="/blog/tags/Css">#Css</a></li>
            <li><a href="/blog/tags/Life">#Life</a></li>
            <li><a href="/blog/tags/Lua">#Lua</a></li>
            <li><a href="/blog/tags/PCB">#PCB</a></li>
            <li><a href="/blog/tags/Shell">#Shell</a></li>
            <li><a href="/blog/tags/C">#C</a></li>
            <li><a href="/blog/tags/html">#html</a></li>
            <li><a href="/blog/tags/%E7%A1%AC%E4%BB%B6">#硬件</a></li>
            <li><a href="/blog/tags/JavaScrip">#JavaScript</a></li>
            <li><a href="/blog/tags/Firewall">#Firewall</a></li>
            <li><a href="/blog/tags/Security">#Security</a></li>
            <li><a href="/blog/tags/Linux">#Linux</a></li>
            <li><a href="/blog/tags/Python">#Python</a></li>
            <li><a href="/blog/tags/Server">#Server</a></li>
            <li><a href="/blog/tags/Web">#Web</a></li>
        </ul>
    <div class="rsstag"><a href="/blog/atom.xml"><span class="iconfont icon-rss"></span>RSS订阅</a></div>
<div class="flower">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="84.6px" height="70.5px" viewBox="0 0 254 212" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>窗</title>
<desc>Created with Sketch.</desc>
<defs></defs>
<g id="植物" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="Artboard" transform="translate(-885.000000, -503.000000)">
        <g id="植物-紫色盆" transform="translate(882.000000, 500.000000)">
            <ellipse id="Oval-12" fill="#B3B7C7" cx="140.5" cy="137" rx="39.5" ry="6"></ellipse>
            <g id="Group-5">
                <path d="M131.5,149 C137.746054,149 138.400559,136.953074 140.297813,118.503702 C141.504079,106.77367 149.145158,88.1140929 147,75 C142.297813,46.2539062 153.271934,32.5660626 150.170125,19.4282488 C148.031314,10.3692495 142.862042,3 131.5,3 C123.603887,3 113.698654,6.59314895 110.722909,11.2157433 C103.206874,22.8913341 114,46.5137576 114,75 C114,90.4435309 122.495151,106.751425 123.699377,118.476362 C125.595832,136.941172 125.250862,149 131.5,149 Z" id="Oval-11" fill="#BAC4F6"></path>
                <path d="M135.5,146.5 C132.598908,121.877878 130.965369,104.566553 130.599381,94.5660242 C130.050399,79.5652312 132.963841,77.0580598 132.164069,55.3464601 C131.630888,40.8720602 130.242865,30.4232402 128,24" id="Line-15" stroke="#FFFFFF" stroke-width="2" opacity="0.800892857" stroke-linecap="square"></path>
                <path d="M77.0442201,163.336077 C84.2239219,163.336077 101.067658,131.237823 101.067658,92.025606 C101.067658,52.8133888 90.9057581,-2.32627732 72.6560979,17.2440872 C50.0508064,41.4852946 69.5871262,36.5862429 74.0442201,63.8595149 C75.572858,73.2133576 77.0442201,94.5993942 77.0442201,104.613421 C77.0442201,143.825638 69.8645184,163.336077 77.0442201,163.336077 Z" id="Oval-9" fill="#BAC4F6" transform="translate(81.510722, 88.251316) rotate(-43.000000) translate(-81.510722, -88.251316) "></path>
                <path d="M42.5,50.5 C47.5132933,48.8699207 59.3816332,57.6317857 78.1050199,76.785595 C96.8284065,95.9394043 113.960067,116.844206 129.5,139.5" id="Line-17" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M155.281006,152.144255 C162.116643,152.144255 178.153197,121.584207 178.153197,84.2511084 C178.153197,72.6051871 184.354199,51.8242671 182.531201,39.8465879 C178.51025,13.4276595 163.058175,0.233079666 151.10317,13.0532528 C129.581164,36.1327785 143.297279,29.7382802 147.540781,55.7045685 C148.996164,64.6101585 153.500382,80.3852665 153.500382,89.9194035 C153.500382,127.252502 148.445368,152.144255 155.281006,152.144255 Z" id="Oval-9-Copy-2" fill="#E9EDFD" transform="translate(161.092971, 80.123972) scale(-1, 1) rotate(-20.000000) translate(-161.092971, -80.123972) "></path>
                <path d="M180.5,34.5 C181.290102,21.4892162 175.746138,28.9223292 163.868108,56.7993391 C157.546037,71.6368512 150.532373,85.3308057 144.827114,101.881203 C141.023608,112.914801 138.581237,128.787733 137.5,149.5" id="Line-20" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M60.3426107,183.894782 C69.2498271,183.894782 90.1463498,156.072081 90.1463498,122.083011 C90.1463498,88.0939419 67.5408019,29.4364067 54.8986583,57.2625442 C45.0326912,78.978146 51.0912584,74.0282851 56.6207779,97.6687014 C58.5172227,105.776593 67.8616068,124.363423 67.8616068,133.043561 C67.8616068,167.032631 51.4353942,183.894782 60.3426107,183.894782 Z" id="Oval-9-Copy" fill="#BAC4F6" transform="translate(69.895982, 116.944107) rotate(-71.000000) translate(-69.895982, -116.944107) "></path>
                <path d="M24.5,109.5 C22.4991751,103.669523 35.0833631,105.49608 62.2525641,114.979669 C79.4278854,120.974828 92.103247,119.378882 106.278649,126.191831 C111.777518,128.834684 120.517968,134.937407 132.5,144.5" id="Line-19" stroke="#FFFFFF" stroke-width="2" opacity="0.595424107" stroke-linecap="square"></path>
                <path d="M169.495543,159.559977 C178.40276,159.559977 199.299282,131.737276 199.299282,97.7482062 C199.299282,85.7856682 202.004463,66.329956 197.824033,53.1018748 C190.126639,28.745108 172.2443,14.8950801 164.051591,32.9277389 C154.185624,54.6433407 160.244191,49.6934798 165.77371,73.3338961 C167.670155,81.4417878 177.014539,100.028618 177.014539,108.708756 C177.014539,142.697825 160.588327,159.559977 169.495543,159.559977 Z" id="Oval-9-Copy-3" fill="#BAC4F6" transform="translate(179.479352, 92.134636) scale(-1, 1) rotate(-43.000000) translate(-179.479352, -92.134636) "></path>
                <path d="M213.5,60.5 C209.183273,60.8948914 201.740861,65.4428024 191.172763,74.1437328 C175.320617,87.1951284 177.797205,83.2393994 161.560337,103.262986 C150.735758,116.612043 142.715646,131.024381 137.5,146.5" id="Line-21" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M81.1425752,168.630026 C85.1025169,165.536181 98.2051544,147.96348 98.2051544,111.236918 C98.2051544,74.5103552 86.0176544,46.7369177 70.0176544,46.7369177 C54.0176544,46.7369177 59.5351666,70.3889964 66.8400325,93.0530589 C69.6371249,101.731312 78.9791535,122.814465 81.0032985,132.88325 C84.2653955,149.110029 78.6989273,170.539213 81.1425752,168.630026 Z" id="Oval-10" fill="#E9EDFD" transform="translate(78.936475, 107.743055) rotate(-52.000000) translate(-78.936475, -107.743055) "></path>
                <path d="M39.5,84.5 C46.5402399,84.832105 55.9862242,87.7506309 67.8379528,93.2555776 C85.6155457,101.512998 79.9127462,96.6348296 100.298442,112.739947 C113.888906,123.476691 125.956092,135.063376 136.5,147.5" id="Line-18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M194.823347,177.534556 C197.785465,175.220296 209.085075,165.125173 213.530819,146.109724 C215.496552,137.701844 211.555235,124.000271 211.555235,111.853141 C211.555235,72.2337887 199.639103,43.8487815 182.378853,43.8487815 C165.118604,43.8487815 168.053621,58.2764613 175.933859,82.7256721 C183.814096,107.174883 191.693317,118.61017 193.876895,129.472028 C197.395933,146.976919 192.187224,179.594121 194.823347,177.534556 Z" id="Oval-10-Copy-2" fill="#E9EDFD" transform="translate(191.881132, 110.738214) scale(-1, 1) rotate(-52.000000) translate(-191.881132, -110.738214) "></path>
                <path d="M237.5,84.5 C231.839918,82.6252532 222.387737,84.7837206 209.143456,90.9754021 C189.277034,100.262925 198.344222,96.9653923 174.587666,113.911421 C158.749962,125.208774 147.387407,137.071634 140.5,149.5" id="Line-22" stroke="#FFFFFF" stroke-width="2" opacity="0.785044643" stroke-linecap="square"></path>
                <path d="M102.095097,154.049614 C106.979303,150.233654 123.140143,128.559423 123.140143,83.2607523 C123.140143,37.9620813 108.108037,3.70622602 88.3735811,3.70622602 C68.639125,3.70622602 75.4444439,32.8787829 84.4542911,60.8327171 C87.9042347,71.5365054 99.4267255,97.5405402 101.923313,109.959415 C105.946795,129.97358 99.0810936,156.404412 102.095097,154.049614 Z" id="Oval-10-Copy" fill="#E9EDFD" transform="translate(99.374086, 78.951409) rotate(-21.000000) translate(-99.374086, -78.951409) "></path>
                <path d="M70.5,27.5 C77.9697854,36.2141564 84.664658,44.2949462 90.5846178,51.7423694 C99.4645574,62.9135043 102.309139,65.8595669 108.078018,74.773869 C113.846897,83.6881711 108.232283,69.1486166 118.500716,94.8794382 C125.346337,112.033319 129.012765,128.573507 129.5,144.5" id="Line-16" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M193.001521,189.153265 C198.929205,189.153265 212.83568,162.652399 212.83568,130.278124 C212.83568,97.9038493 204.210737,49.7003434 189.378612,68.5372278 C174.540517,87.3816949 180.150684,86.5530431 183.830536,109.070321 C185.092606,116.793013 193.001521,132.403088 193.001521,140.670839 C193.001521,173.045114 187.073837,189.153265 193.001521,189.153265 Z" id="Oval-9-Copy-4" fill="#BAC4F6" transform="translate(196.248002, 126.727326) scale(-1, 1) rotate(-73.000000) translate(-196.248002, -126.727326) "></path>
                <path d="M234.5,116.5 C229.435614,115.997419 220.043174,117.148484 206.322678,119.953197 C185.741934,124.160265 185.201799,123.9696 168.145826,131.063968 C156.775178,135.793546 148.226569,140.93889 142.5,146.5" id="Line-23" stroke="#FFFFFF" stroke-width="2" opacity="0.733426339" stroke-linecap="square"></path>
            </g>
            <g id="Group-4" transform="translate(101.000000, 137.000000)">
                <path d="M0,0 C11.7955729,2 24.5052083,3 38.1289062,3 C51.7526042,3 65.3763021,2 79,0 L71.2109375,75.3409091 C61.9375,77.1136364 51.8945312,78 41.0820312,78 C30.2695313,78 19.4570312,77.1136364 8.64453125,75.3409091 L0,0 Z" id="Rectangle-9" fill="#FCDCCF"></path>
                <path d="M59.2621996,2.19791001 C63.6483775,1.86496527 70.2276443,1.1323286 79,0 L71.2109375,75.3409091 C63.3055851,76.5844933 57.2271178,77.3450382 52.9755357,77.6225437 L59.2621996,2.19791001 Z" id="Rectangle-9" fill="#ECC6B6"></path>
                <path d="M0,0 C10.9588352,1.33333333 23.3572727,2 37.1953125,2 C51.0333523,2 64.9682481,1.33333333 79,0 L76.7909585,21.3672948 L40.573652,23.0934676 L2.38711382,20.8047516 L0,0 Z" id="Rectangle-9" fill="#F3B096"></path>
            </g>
        </g>
    </g>
</g>
</svg>
</div>

</div>
<div class="menu-btn closed"> 
    <div class="menu-line"></div>
    <div class="menu-line"></div>
    <div class="menu-line"></div>
</div>
<div class="main">
    <div class="msg">
        <div class="msg-text"></div>
        <div class="msg-bar"></div>
    </div>
    <div class="motto">
        <p> //sunny forever<br />
            while(life&lt;end){<br />
               love++;<br />
               beAwesome :)} </p>
     </div>
     <div class="main-content">
    <div class="set-wrapper">
    <ul class="set-menu">
        <div id="set-btn" class="set-button"><</div>
        <li class="search-container">
            <input id="search-input" class="local-search" placeholder="搜索..." type="search" >
            <span class="search-ico"></span>
        </li>
        <li id="toggle-theme">
        主题：<span class="theme-ico sun"></span>
        </li>
        <li class="set-size">
            <span id="increase-font-size">+</span>
            <span class="font-size-num"></span>
            <span id="reduce-font-size">-</span>
        </li>
        <li id="clear-back">清除背景</li>
        <li id="disable-back">禁用背景</li>
    </ul> 
</div>
    <div class="result-container">
        <div id="search-result" class="display-result"></div>
    </div>
    <div class="toc-wrapper"><div class="toc-btn">目 录</div><div class="toc-box"><!--tocBox用于容纳生成在toc外的目录--><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd"><span class="toc-number">1.</span> <span class="toc-text">systemd</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">配置文件路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">配置文件说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">配置文件语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unit%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">unit的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unit%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">unit的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unit%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">unit单元文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">2.1.</span> <span class="toc-text">单元文件路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unit-%E5%9D%97"><span class="toc-number">2.2.</span> <span class="toc-text">[Unit]块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Install-%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">[Install]块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Service类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Service-%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">[Service]块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">service配置案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Target类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%A2%84%E5%AE%9A%E4%B9%89Target"><span class="toc-number">4.2.</span> <span class="toc-text">运行级别与预定义Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#target%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">target常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E4%B8%8Etarget"><span class="toc-number">4.4.</span> <span class="toc-text">开机自启动与target</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemctl"><span class="toc-number">5.</span> <span class="toc-text">systemctl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">系统管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.</span> <span class="toc-text">查看系统状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">单元管理命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%85%83%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text">常用的单元管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#systemctl-status%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.4.1.</span> <span class="toc-text">systemctl status返回值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">5.5.</span> <span class="toc-text">单元状态查询命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-journald"><span class="toc-number">6.</span> <span class="toc-text">systemd-journald</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">6.1.</span> <span class="toc-text">日志文件存储路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#journalctl%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">journalctl日志命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text">日志服务配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95-1"><span class="toc-number">6.4.</span> <span class="toc-text">配置文件语法</span></a></li></ol></li></ol></div></div>
        <div class="article">
        <h1 class="title">systemd</h1>
        <div class="art-info">
            <div><span><span class="iconfont icon-zishu-jzl"></span>字数：25339</span>
            <span><span class="iconfont icon-riqi"></span>写于：2025-07-21</span></div>
            <div><span><span class="iconfont icon-zuixinnew3"></span>最新更新：2025-07-21</span>
            <span><span class="iconfont icon-shijian"></span>阅读本文预计花费您73分钟</span></div>
        </div>
        <div class="art-content">
        <h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>systemd 是由Lennart Poettering(当时就职于Red Hat公司)领导开发的一套Linux服务和系统管理工具，用来为Linux提供一种更高效的启动管理机制以替代曾经的initd守护进程，并为用户提供并行化管理服务。systemd在Linux启动时会作为系统的第一个进程(PID为1)启动，然后由其负责启动系统的其它进程，大多数现代 Linux 发行版(如 Ubuntu、Debian、Fedora、CentOS、Arch Linux 等)都默认使用systemd来管理服务和系统进程，systemd主要提供以下功能：</p>
<ul>
<li>服务管理：管理各类服务的启动、自启动、停止</li>
<li>依赖管理：管理服务依赖关系，确保服务按正确顺序启动</li>
<li>日志记录：提供 journald 日志系统，收集和存储系统日志</li>
<li>设备和挂载管理：支持动态设备挂载和自动挂载</li>
<li>维护基本系统配置：管理系统主机名、日期、区域设置，维护已登录用户和网络时间同步等</li>
</ul>
<div class="broadcast color-yellow">
<div class="iconfont icon-dengpao14hao"></div>
systemd官网：<a target="_blank" rel="noopener" href="https://systemd.io/">https://systemd.io/</a></div>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h5><p>systemd 的配置文件路径是编译时指定的，用户无法修改，systemd所有的配置文件基本都存放在以下几个目录中，根据优先级顺序依次为：</p>
<ul>
<li><span class="strong">/etc/systemd/</span>：存放用户配置文件，<span class="tips">优先级最高</span>，如果其他目录中存在与该目录下的文件同名的配置文件，则该目录中的文件会覆盖其他路径中的同名文件</li>
<li><span class="strong">/run/systemd/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件等，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li>
<li><span class="strong">/usr/lib/systemd/(或 /lib/systemd/)</span>：系统提供的默认配置文件，<span class="tips">优先级最低</span>，方便用户覆盖</li>
</ul>
<p>除了以上目录外，用户还可以创建如/etc/systemd/*.conf.d/,/usr/lib/systemd/*.conf.d/等类似的drop-in配置子目录，这些drop-in将具有更高的优先级</p>
<h5 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h5><p>以上目录中通常同时包含多种不同类型的systemd配置文件，以<span class="tips">/etc/systemd/</span>为例，该目录下可能存在以下文件或目录：</p>
<ul>
<li>/etc/systemd/system.conf：系统级systemd配置文件，是systemd软件自身的配置文件，定义了很多影响 systemd 行为的全局设置。它控制系统级的资源管理、进程限制等</li>
<li>/etc/systemd/user.conf：用户级别的systemd配置文件，类似于 system.conf，该文件控制的是用户级别的服务行为</li>
<li>/etc/systemd/system/：存放全局的单元(Unit)文件，该目录中存放的单元文件通常是系统级的守护进程、服务、挂载单元、target单元、定时单元等，通常由管理员创建且需要root权限</li>
<li>/etc/systemd/user/：用于存放用户级别的单元文件，通常是一些仅在用户会话中运行的服务，不需要root权限</li>
<li>/etc/systemd/journald.conf：systemd日志系统journald的配置文件，用于定义日志的存储、大小、级别等参数</li>
<li>/etc/systemd/network/：该目录用于配置与网络相关的systemd 网络管理单元，包含网络接口配置文件(如静态IP配置)等</li>
<li>/etc/systemd/logind.conf：用于配置与systemd-logind相关服务，管理用户会话和登录等</li>
</ul>
<h5 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a>配置文件语法</h5><p>systemd的配置文件语法参考了XDG Desktop Entry规范，而XDG的语法又受到Windows中.ini文件的影响，以下是systemd中各类配置文件的一些通用语法规则：</p>
<ul>
<li>配置文件都是纯文本文件，以<span class="tips">key=value</span>形式指定</li>
<li>空行和以<span class="tips">#</span>、<span class="tips">;</span>开头的文件会被忽略，因此这两个符号可用来写注释行</li>
<li>配置文件中，如果内容在一行中写不下，可以使用反斜杠<span class="tips">\</span>在下一行续写，systemd在读取时会将两行合并，并使用空格替换反斜杠。如果反斜杠后为注释行，则注释行会被忽略，systemd将合并注释行后的内容</li>
<li>配置文件中的布尔值可以以各种格式书写，如：1、yes、true、on等价；0、no、false、off等价</li>
<li>配置文件中的时间，不标注单位时默认以秒为单位，单位支持使用y(year,years)、M(months, month)、w(weeks, week)、d(days, day)、h(hours, hour, hr)、m(minutes, minute, min)、s(seconds, second, sec)、ms(msec)、us(usec)</li>
<li>配置文件支持使用C语言的转义字符</li>
</ul>
<h4 id="unit的类型"><a href="#unit的类型" class="headerlink" title="unit的类型"></a>unit的类型</h4><p>systemd将系统资源和服务抽象为各种单元(unit)，并使用单元配置文件来创建和管理单元，systemd一共提供了11种unit：</p>
<ul>
<li><span class="strong">Service unit</span> 用于定义和管理各类服务，如启动、停止、重启服务</li>
<li><span class="strong">Socket Unit</span> 用于管理网络或 FIFO管道，当有基于Socket的连接时自动启动对应的服务</li>
<li><span class="strong">Target unit</span> 将多个unit组合为一个组，进行统一的管理(开启、关闭、依赖等)</li>
<li><span class="strong">Mount Unit</span> 用于定义和管理挂载点</li>
<li><span class="strong">Automount Unit</span>用于自动挂载，通常与.mount 配合使用，仅在访问时才挂载资源</li>
<li><span class="strong">Path Unit</span> 用于监控文件或目录的状态变化，当条件满足时触发相关服务</li>
<li><span class="strong">Slice Unit</span> 切片单元，用于对一组进程进行系统资源的分配与限制</li>
<li><span class="strong">Scope Unit</span> 与service类似，但Scope是由systemd根据 D-bus 接口接收到的信息自动创建，通常用于管理非 Systemd启动的外部进程</li>
<li><span class="strong">Device Unit</span> 用于表示系统中的硬件设备</li>
<li><span class="strong">Swap Unit</span> 用于管理交换分区或交换文件</li>
<li><span class="strong">Timer Unit</span> 定时器，用来替代传统的crond等，以执行定时任务</li>
</ul>
<h4 id="unit的状态"><a href="#unit的状态" class="headerlink" title="unit的状态"></a>unit的状态</h4><p>系统中的unit通常可以处于以下状态，各种单元类型可能会在此基础之上具有许多额外的子状态</p>
<ul>
<li>active 活动状态，表示单元已经启动、激活等</li>
<li>inactive 停止</li>
<li>activating 正在启动</li>
<li>deactivating 正在停止</li>
<li>failed  失败</li>
<li>maintenance  单元已停止，且在进行维护操作</li>
<li>reloading 正在重新加载其配置</li>
</ul>
<h3 id="unit单元文件"><a href="#unit单元文件" class="headerlink" title="unit单元文件"></a>unit单元文件</h3><h4 id="单元文件路径"><a href="#单元文件路径" class="headerlink" title="单元文件路径"></a>单元文件路径</h4><p>unit单元文件目录位于systemd配置文件路径下，根据优先级顺序依次为：</p>
<ul>
<li><span class="strong">/etc/systemd/system/</span>：存放系统级单元文件，<span class="tips">优先级最高</span>，如果其他目录存在与系统单元文件同名的文件，则该目录中的文件会覆盖其他路径中的同名文件</li>
<li><span class="strong">/run/systemd/system/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li>
<li><span class="strong">/usr/lib/systemd/system/(或 /lib/systemd/system/)</span>：系统提供的默认单元文件，<span class="tips">优先级较低</span>，通常由软件包管理器安装配置</li>
</ul>
<p>system目录用来存放系级单元文件，该路径下还存在user目录，如果需要存放用户单元文件，只需要将以上路径中的system改为user即可，单元文件名需要遵守以下规则：</p>
<ul>
<li>单元文件名前缀可以包含字母、数字和-._:\符号</li>
<li>必须包含单元类型后缀，如：game-start.service</li>
</ul>
<h4 id="Unit-块"><a href="#Unit-块" class="headerlink" title="[Unit]块"></a>[Unit]块</h4><p>[Unit]部分用来书写单元的通用信息，且所有类型的单元文件都会有该块，只列出了部分配置项，完整的[unit]块配置请参考：</p>
<div class="broadcast color-pink">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html</a>
</div>

<ul>
<li><p><span class="strong">Description=</span><br>指定对该单元的简短描述，根据官方文档，这里的属性虽然是Description，但所指定的字符串应该是对该单元功能或身份的简洁”标识”或”标签”，方便用户快速识别，而不是详细描述它，如果需要详细描述，应该写在Documentation字段指向的外部文档中。Description所指定的字符串，systemcted会在状态消息中(如执行 systemctl status时)显示该字符串(因此应该开头大写)，如：Description=Nginx Web Server，systemd将在启动nginx时显示Starting Nginx Web Server</p>
</li>
<li><p><span class="strong">Documentation=</span><br>该单元以及其配置文件的相关文档，可以指定多个URI(可以是URL或URN)，使用空格进行分隔。这里的URI仅支持”http://“、”https://“、”file：”、”info：”、”man：” 类型的 URI，如：man:command(6)</p>
</li>
<li><p><span class="strong">Wants=</span><br>指定该单元的弱依赖单元，即使依赖单元启动失败，该单元仍会继续运行。此选项可以多次指定，也可以在一个选项中指定多个空格分隔的单位。注意，该选项配置的依赖关系不会影响服务的启动顺序，通常情况下，依赖单元和当前单元会同时启动。向单元文件附带的 .wants/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p>
</li>
<li><p><span class="strong">Requires=</span><br>指定该单元的强依赖单元，该单位启动时，也将启动该选项配置的这些单元。如果依赖单元启动失败、中途被”显式”停止或重启，该单元也将相应地启动失败、停止、重启。但这并不意味着当此单元运行时，另一个单元必须始终处于活动状态，如：单元启动成功后，某些依赖单元完成使命正常退出，这将不会影响到当前的单元。向单元文件附带的 .requires/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p>
</li>
<li><p><span class="strong">Requisite=</span><br>类似于requires，但是，该选项配置的是当前单元运行的必要前提条件，即当前单元运行前，这些单元必须已经运行，如果该选项指定的单元未启动，systemd将不再尝试启动当前单元，而将直接判定启动失败。因此，该设置通常与 After= 结合使用，以确保当前单元不会在Requisite配置的单元之前启动</p>
</li>
<li><p><span class="strong">BindsTo=</span><br>类似于requires，但BindsTo所绑定的依赖关系更强，除了拥有requires的特点外，BindsTo会将当前单元的生命周期绑定到依赖单元，当前单元的运行严格依赖于依赖单元的存续。BindsTo所绑定的单元如果停止，则当前单元也将停止。该配置项用于需要紧密关联的单元，例如一个服务与其挂载点的绑定，如果挂载点被卸载或停止，当前服务也停止</p>
</li>
<li><p><span class="strong">Upholds=</span><br>类似于Wants，但不同点在于，当前单元对Wants所指定单元的依赖是一次性的，systemd只会在启动当前单元时尝试启动Wants中指定的依赖，后续这些依赖是否停止，systemd都不再关心。而当前单元对Upholds所指定单元的依赖是持续性的，如果后续当前单元还在运行，而Upholds单元中途停止，systemd将不断尝试重启它们，即便它们不是强依赖单元。</p>
</li>
<li><p><span class="strong">Conflicts=</span><br>指定冲突单元，表示两个单元之间存在冲突关系，不能同时运行。如：假设A.service的配置文件中配置了Conflicts=B.service，则在启动A时，如果B正在运行，将关闭B。同样，如果启动B时，A正在运行，则将关闭A，即使B的配置中未显式声明Conflicts=A。注意，Conflicts同样不会指定服务的启动或关闭顺序，如果需要确保在启动A单元之前，先停止B单元，需要显式添加After或Before配置</p>
</li>
<li><p><span class="strong">Before=</span><br>定义单元的启动顺序，表示当前单元必须在Before所指定的单元之前启动，关闭时必须在这些单元之后关闭。如：A的配置文件配置了Before=B，则A必须在B之前启动，在B之后关闭。</p>
</li>
<li><p><span class="strong">After=</span><br>定义单元的启动顺序，表示当前单元必须在After所指定的单元之后启动，关闭时必须在这些单元之前关闭。如：A的配置文件配置了After=B，则A必须在B之后启动，在B之前关闭。</p>
</li>
<li><p><span class="strong">ConditionPathExists=</span><br>检查所指定的路径和文件是否存在，如果指定的绝对路径名不存在，将停止启动单元。可以在路径前加上一个<span class="tips">!</span>，表示当该文件不存在时，才启动该单元</p>
</li>
</ul>
<h4 id="Install-块"><a href="#Install-块" class="headerlink" title="[Install]块"></a>[Install]块</h4><p>[Install]块用于配置单元的安装和启用信息，</p>
<div class="broadcast color-green">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options</a></div>

<ul>
<li><p><span class="strong">Alias=</span><br>定义单元的别名，<span class="tips">该别名必须与原单元文件名具有相同的后缀(即type)</span>，可以指定多个别名，空格分隔。指定了别名后，在使用systemctl enable开机自启用单元时，将在<span class="tips">/etc/systemd/system</span>对应目录中创建一个符号链接并指向<span class="tips">/usr/lib/systemd/system</span>目录中的原单元文件，此后，用户可以通过这些别名启动服务</p>
</li>
<li><p><span class="strong">WantedBy=</span><br>指定当前单元希望被哪些单元作为依赖使用(弱依赖)，可以指定多个值，空格分隔。指定了值后，当通过 systemctl enable 命令安装当前单元时(开机自启动)，将会在这些WantedBy所指定的每一个单元的<span class="tips">.wants/</span> 目录中创建一个当前单元的符号链接。这里通常会指定一个target类型的单元值，即指定当前单元在哪种Linux开机模式下会被启动，如：在服务A的配置文件中添加WantedBy　=　multi-user.target，则在执行systemctl enable A.service启用A单元后，systemd将在/etc/systemd/system/multi-user.target.wants目录中创建一个符号链接A.service，该符号链接指向/usr/lib/systemd/system/A.service，表示A服务会在Linux以常规多用户模式启动时开机自启动。当然配置的值也可以是其他unit类型，如：在服务A的配置文件中添加WantedBy　=　B.service，则A的符号链接将被添加到B.service.wants目录中，表示启动服务B时，希望启动A。指定服务依赖的功能和[Unit]块中的wants有点类似，不同点在于：</p>
<blockquote>
<blockquote>
<ul>
<li>Wants指定当前单元需要哪些依赖，WantedBy指定当前单元是其他单元的依赖</li>
<li>Wants指定单元运行时的依赖关系，单元的设置会在启动或加载时立即生效；WantedBy定义单元安装时依赖关系，需要使用 systemctl enable 使其生效</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<ul>
<li><p><span class="strong">RequiredBy=</span><br>指定当前单元必须被哪些单元作为依赖使用(强依赖)，这意味着当前单元的运行失败，将影响到其他单元的运行。用法与WantedBy类似，这里所指定的每一个单元，它们的<span class="tips">.Requires/</span>目录中将有可能被添加当前单元的符号链接(取决于当前单元是否开机自启动)</p>
</li>
<li><p><span class="strong">UpheldBy=</span><br>指定当前单元是哪些单元的维持性依赖，具体的依赖关系参考[Unit]块的Upholds，用法与WantedBy类似，但它没有类似的.Uphold目录，用于动态维持目标状态，使用场景较少</p>
</li>
<li><p><span class="strong">Also=</span><br>当使用systemctl enable 或 systemctl disable命令安装/卸载当前单元时，需要一起安装/卸载的其他单元，可以指定多个值，空格分隔</p>
</li>
</ul>
<h3 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h3><h4 id="Service-块"><a href="#Service-块" class="headerlink" title="[Service]块"></a>[Service]块</h4><p>[Service]块是service类型的单元文件专属块，也是必须块，以下是部分配置项,完整[service]块的配置可参考:</p>
<div class="broadcast color-yellow">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html">systemd.service — Service unit configuration</a>
</div>

<ul>
<li><span class="strong">Type=</span><br>用于定义服务的启动类型，指定systemd 如何识别服务的启动完成状态以及如何管理服务的主进程，它支持以下值：<blockquote>
<blockquote>
<ul>
<li><span class="strong">simple</span>：<br>systemd在启动服务时，会fork()一个systemd服务管理子进程，然后在子进程中运行该服务。当指定Type=simple时，systemd服务管理器会在fork()结束后立即返回服务已经启动的状态，即便此时服务的二进制文件还未真正执行，甚至可能会执行失败(如权限不足)，因此该值可能具有一些潜在风险(如systemctl start命令错误返回服务启动状态，systemd因为识别服务已经启动而继续启动其他依赖造成启动顺序错误)，该值适用于一些简单的单进程服务或脚本。当指定了 ExecStart= 但未指定 Type= 和 BusName=时，该值是默认值</li>
<li><span class="strong">exec</span>：<br>类似于simple，但systemd服务管理器会等到服务的二进制文件被执行后才返回服务已启动的状态(即execve()系统调用完成后)，因此该值不会存在二进制文件执行失败，但systemd识别为服务已经启动的情况。如果二进制文件执行失败，systemctl start 命令将正确报告服务启动失败状态。如果服务主进程会fork()子进程，exec不会等待其派生(fork)的子进程完成，该情况下应该选择使用Type=forking或者其他类型。因此，exec适用于那些可直接执行，不可再 fork 的长期任务，而不适用于守护进程，或者需要通过shell等脚本管理的复杂服务(如果对通过shell启动管理的服务指定exec类型，则systemd会只关注shell本身的启动，而不是shell启动的主服务)</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">forking</span>：服务会通过父进程创建子进程(fork)的方式运行，并且父进程会退出，子进程作为服务的主进程。这是传统UNIX守护进程设计模式的一种方式，当一个进程启动时，通常会绑定到启动它的终端tty，如果终端关闭，进程可能会受到 SIGHUP 信号的影响而退出，因此传统的守护进程(daemon)设计时，会先启动一个父进程，然后通过fork()创建子进程，然后父进程退出，子进程作为主进程继续运行。此时子进程可以在一个相对干净的环境中运行，且脱离了终端控制，成为孤儿进程并交由systemd接管。当Type=forking时，systemd会在父进程退出时，视为服务启动完成，由于这是传统UNIX的设计，因此对于现代项目，文档不建议使用此类型，而是建议改用 notify、notify-reload 或 dbus。如果一定要用该类型，建议同时PIDFile= 选项一起使用，以便 systemd 能够可靠地识别服务的主进程</li>
<li><span class="strong">notify</span>：notify的行为类似于exec，不同之处在于服务在完成启动时会通过 sd_notify()或其他兼容的库的类似调用向systemd 发送”READY=1”消息，来告诉systemd当前服务已经启动完成。systemd会等待通知消息后再认为服务已启动。适用于需要执行一些初始化工作后，明确通知启动完成的服务</li>
<li><span class="strong">oneshot</span>：类似于simple，但oneshot表示该服务是一次性的短期任务，systemd会在该服务成功执行并退出后才视为服务启动完毕，然后开始执行后续任务。该类型适合用来配置哪些需要前期迅速执行完毕，为后续任务铺设环境的一次性任务，如初始化脚本、配置加载、清理上次登录的临时文件等任务。该选项通常需要配合 RemainAfterExit=true 配置项，来让systemd在返回其状态时返回值为”active”，否则，由于该服务会在执行完毕后退出，会导致其状态会直接从”activating”跳到”dead”或”deactivating”。当Type=和ExecStart=配置均未指定时，systemd将默认指定Type=oneshot</li>
<li><span class="strong">dbus</span>：dbus的行为类似于simple，但这种类型的单元必须指定 BusName= 配置，相反，如果指定了BusName=的值而未指定Type，则默认为Type=dbus。服务通过D-Bus总线注册完成后，systemd才会认为它已启动，该类型适用于基于D-Bus的服务</li>
<li><span class="strong">idle</span>：类似于simple，但服务的启动会延迟到所有其他任务完成后再运行，避免服务启动时，shell的输出混乱。该值仅用于避免控制台输出混乱，不用作通用的unit启动排序工具，因此服务启动延迟时间限制为5s，超时后无论如何都会启动服务。可用于非关键任务，让它们系统启动完成后再启动</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p><span class="strong">ExitType=</span><br>指定退出类型，告诉systemd服务管理器何时认为当前unit已经关闭，有以下两个取值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">main</span>：默认值，当服务主进程退出时，认为该单元已经停止。由于oneshot类型的服务是在主进程退出后才视为服务开始启动，因此该值不能与Type=oneshot 一起使用，</li>
<li><span class="strong">cgroup</span>：只要 cgroup 中至少有一个进程尚未退出，该服务就会被视为正在运行</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">ExecStart=</span><br>启动服务时执行的命令，如果服务类型Type是oneshot，可以指定多个命令，否则<span class="text-red">只能指定一个命令！</span>通过该命令启动的进程将被视为守护进程的主进程(Type=forking的服务除外，因为此时子进程才是主进程)。当Type=oneshot时，可以指定多个要执行的命令，空格分隔，systemd会依次执行它们，如果其中一个命令失败，则该单元会被视为启动失败。可以在命令前添加”-“，则此时即便该命令执行失败，systemd也会继续执行后续命令，且不会视为单元启动失败。</p>
</li>
<li><p><span class="strong">RemainAfterExit=</span><br>一个boolean值，该值指定是否应将服务视为活动状态，即使其所有进程都已退出，默认为 no，通常Type=oneshot会用到该配置项</p>
</li>
<li><p><span class="strong">PIDFile=</span><br>指定一个PID文件路径，通常是/run目录下的路径，该配置项通常用来搭配Type=forking配置，以此告诉systemd服务管理器从该PID文件中读取服务主进程的PID，文档建议现代项目中尽量少使用</p>
</li>
<li><p><span class="strong">BusName=</span><br>指定服务应使用的D-Bus目标名称，该配置项是Type=dbus时的必须配置</p>
</li>
<li><p><span class="strong">ExecStartPre=</span><br>在 ExecStart= 所指定的命令执行前执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStart所指定的命令只会在ExecStartPre所指定的所有命令(不以”-“前缀)成功退出后才开始执行</p>
</li>
<li><p><span class="strong">ExecStartPost=</span><br>在 ExecStart= 所指定的命令执行后执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStartPost所指定的命令只会在ExecStart所指定命令成功启动后执行，具体执行时间取决于systemd何时收到服务启动通知，具体参考Type配置项各类型的服务何时视为启动成功</p>
</li>
<li><p><span class="strong">ExecReload=</span><br>服务的配置被重新加载时需要执行的命令，可以指定多个命令，遵循与ExecStart=相同的配置方案</p>
</li>
<li><p><span class="strong">ExecStop=</span><br>指定停止当前服务时用户需要输入的命令，该配置遵循与ExecStart=相同的配置方案，该配置项是可选的，如果没有设置该配置，则服务停止时，将通过发送 KillSignal= 或 RestartKillSignal= 中指定的信号来终止进程。</p>
</li>
<li><p><span class="strong">ExecStopPost=</span><br>在服务停止后执行的其他命令，服务停止的方式可以是通过执行ExecStop所指定的命令、启动失败停止、服务意外退出、收到系统信号终止等，这些都会触发systemd执行ExecStopPost所指定的命令。该配置项常用来设置一些服务停止后的清理工作，或者服务启动失败时，清理不完整的初始化数据</p>
</li>
<li><p><span class="strong">RestartSec=</span><br>指定重新启动服务之前的休眠时间，可以直接指定一个数值(单位为秒)，也可以是时间跨度(如：5min 20s)，默认为100ms</p>
</li>
<li><p><span class="strong">Restart=</span><br>配置在服务进程退出(exit)、终止(kill)或达到超时(timeout)时是否应重新启动服务，支持以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">no</span>：默认值，不重启服务</li>
<li><span class="strong">on-success</span>：仅当服务服务正常退出(退出代码是零)时才重启</li>
<li><span class="strong">on-failure</span>：服务因非零退出代码或异常信号失败时重启</li>
<li><span class="strong">on-abnormal</span>：服务因异常信号(如：SIGKILL、SIGSEGV等)终止时会重启</li>
<li><span class="strong">on-watchdog</span>：服务因看门狗超时被杀死时会重启，适用于需要高可靠性的服务，并启用了看门狗功能。systemd中，看门狗是用来监控服务或进程是否正常运行的进程，服务需要每隔一段时间就向看门狗发送一个报告，来表示服务在正常运行，如果超时时间内没有报告，systemd会认为服务卡住或挂起，然后会尝试重启或唤醒服务</li>
<li><span class="strong">on-abort</span>：服务因收到 SIGABRT信号终止时会重启，适用于需要响应服务主动触发中止操作的场景</li>
<li><span class="strong">always</span>：无论服务如何退出（成功、失败或异常），都进行重启</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<div class="broadcast color-pink">
<div class="iconfont icon-yinle1"></div>
以下配置项也可以写于[service]块中以指定执行环境、执行身份，参考文档：
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html">systemd.exec — Execution environment configuration</a></div>

<ul>
<li><p><span class="strong">User=,Group=</span><br>指定服务的执行用户或用户组，只能指定单个，用户或组可以以名称形式或数字ID形式指定，但极限于以root身份启动systemd的情况下。如果以其他身份启动systemd，则不允许切换身份，该配置项无效</p>
</li>
<li><p><span class="strong">StandardInput=</span><br>控制标准输入连接到何处，可取以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">null</span>：(默认)连接到/dev/null，进程的所有读取尝试都将导致立即 EOF</li>
<li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li>
<li><span class="strong">file:绝对路径</span>：连接到该文件</li>
<li><span class="strong">data</span>：传递一段文本或二进制数据给当前服务，传递内容通过StandardInputText=/StandardInputData=指定</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">StandardOutput=</span><br>控制标准输出连接到何处，可取以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">inherit</span>：将标准输入的文件描述符复制给标准输出</li>
<li><span class="strong">null</span>：连接到 /dev/null，丢弃所有输出</li>
<li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li>
<li><span class="strong">journal</span>：(默认)连接到journal日志</li>
<li><span class="strong">kmsg</span>：连接到内核日志缓冲区</li>
<li><span class="strong">journal+console</span>：连接到日志并输出一份到控制台</li>
<li><span class="strong">file:绝对路径</span>：连接到该文件</li>
<li><span class="strong">append:绝对路径</span>：以附加形式连接到该文件</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">StandardError=</span><br>控制标准错误输出连接到何处，可取与StandardOutput相似</p>
</li>
<li><p><span class="strong">StandardInputText=, StandardInputData=</span><br>指定一段文本或二进制数据，通过标准输入传递给当前服务，需要指定 StandardInput=data，否则该配置项不生效</p>
</li>
</ul>
<div class="broadcast color-blue">
<div class="iconfont icon-yinhao"></div>
以下配置项也可以写于[service]块中以指定执行用户和组，参考文档</div>

<h4 id="service配置案例"><a href="#service配置案例" class="headerlink" title="service配置案例"></a>service配置案例</h4><div class="shell">e.g.Nginx的配置
[Unit]
Description=The NGINX HTTP and reverse proxy server
After=network.target</br>
[Service]
Type=forking
ExecStart=/usr/sbin/nginx
ExecReload=/usr/sbin/nginx -s reload
ExecStop=/usr/sbin/nginx -s stop
PIDFile=/run/nginx.pid
PrivateTmp=true</br>
[Install]
WantedBy=multi-user.target
</div>

<div class="show">写一个shell脚本，通过systemd管理，要求：
testA.sh的输出信息输出到终端而不是日志，testA.sh执行前输出启动提示文本
testA.sh弱依赖testB.sh
testB.sh的输出信息输出到日志
1.编写/myShell/testA.sh内容
#!/bin/bash
echo "脚本A开始执行"
sleep 5
echo "脚本A执行完毕"
2.编写/myShell/testB.sh内容
#!/bin/bash
echo "脚本B开始执行"
sleep 3
echo "脚本B执行完毕"
3.赋予脚本可执行权限
chmod +x testA.sh testB.sh
4.编写/etc/systemd/system/testA.service内容
[Unit]
Description=test A service
Wants=testB.service<br>
[Service]
Type=oneshot  #simple类型不会等待脚本执行完毕返回，oneshot则会等待脚本执行
ExecStart=/myShell/testA.sh
StandardOutput=tty
StandardError=tty
TTYPath=/dev/pts/0
ExecStartPre=/bin/echo "服务A启动"
5.编写/etc/systemd/system/testB.service内容
[Unit]
Description=test B service<br>
[Service]
Type=simple
ExecStart=/myShell/testB.sh
6.让systemd重新加载配置
systemctl daemon-reload
7.执行testA服务
systemctl start testA
</div>


<h3 id="Target类型"><a href="#Target类型" class="headerlink" title="Target类型"></a>Target类型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>target 是一种特殊的单元类型，用于将多个相关的服务或单元组合到一起，然后一次性启动或关闭，这样就不需要手动一个个启动这些单元了。systemd预定义了一些target类型的单元，用于在特定情况启动(如：插入声卡、连接蓝牙时)，其中包括一些系统关闭或启动时会执行的单元，这些target类型的单元对应传统的 SysV 运行级别(runlevel)，用户也可以自行创建并配置target单元</p>
<p>target类型的Unit单元配置文件仅支持[Unit] 和 [Install]配置块，不存在专属[Target]块</p>
<h4 id="运行级别与预定义Target"><a href="#运行级别与预定义Target" class="headerlink" title="运行级别与预定义Target"></a>运行级别与预定义Target</h4><div class="table">

<table>
<thead>
<tr>
<th>运行级别(runlevel)</th>
<th>systemd target(target别名)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>poweroff.target(runlevel0.target)</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>rescue.target(runlevel1.target)</td>
<td>单用户状态，只启动系统核心，用于系统修复和维护</td>
</tr>
<tr>
<td>2</td>
<td>multi-user.target(runlevel2.target)</td>
<td>多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护</td>
</tr>
<tr>
<td>3</td>
<td>multi-user.target(runlevel3.target)</td>
<td>完全多用户状态，具有完整的功能</td>
</tr>
<tr>
<td>4</td>
<td>无</td>
<td>系统未使用，保留</td>
</tr>
<tr>
<td>5</td>
<td>graphical.target(runlevel5.target)</td>
<td>GUI模式，桌面版Linux专属</td>
</tr>
<tr>
<td>6</td>
<td>reboot.target(runlevel6.target)</td>
<td>系统重启</td>
</tr>
</tbody></table>
</div>

<div class="broadcast color-pink">
查看更多预定义的target：<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.special.html">systemd.special — Special systemd units
</a>
</div>

<h4 id="target常用命令"><a href="#target常用命令" class="headerlink" title="target常用命令"></a>target常用命令</h4><ul>
<li><p><span class="strong">systemctl isolate target名</span>临时切换到该target(可以实现临时切换运行级别)</p>
</li>
<li><p><span class="strong">systemctl set-default target名</span>设置默认目标(持久化修改开机运行级别)</p>
</li>
</ul>
<h4 id="开机自启动与target"><a href="#开机自启动与target" class="headerlink" title="开机自启动与target"></a>开机自启动与target</h4><p>当用户执行<span class="tips">systemctl enable unit名</span>设置单元开机自启动时，systemd会在<span class="tips">/etc/systemd/system/multi-user.target.wants/</span>(假设当前开机默认启动target为multi-user.target)中创建一个该单元文件的符号链接，这样就实现了开机启动该单元的功能。相反，当用户执行<span class="tips">systemctl disable unit名</span>来禁止单元开机自启动时，systemd会删除<span class="tips">/etc/systemd/system/multi-user.target.wants/unit名 </span>符号链接，从而阻止其在系统启动时自动启动。</p>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl是systemd的提供的主要命令行工具，用来通过统一的接口来管理系统的各项服务，调用systemctl时会默认使用<span class="tips">-&zwnj;-system</span>选项，用于管理系统级单元，这可能需要root权限。如果需要管理用户级单元，应该显式指定<span class="strong">systemctl -&zwnj;-user</span></p>
<h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><p>在systemd被广泛运用到各发行版中后，Linux中传统的系统管理命令(如：halt、poweroff、reboot等)通常会调用systemd 提供的命令，如：执行 halt 实际上会调用 systemctl halt命令</p>
<ul>
<li><div class="strong">systemctl is-system-running</div>
检查系统是否正常运行，是则返回0，如果系统处于正在启动、维护、关闭状态，或者有失败的启动服务时，返回非零值</li>
<li><span class="strong">systemctl default</span>进入默认模式</li>
<li><span class="strong">systemctl rescue</span>进入救援模式</li>
<li><span class="strong">systemctl emergency</span>进入紧急模式</li>
<li><span class="strong">systemctl halt</span>关闭系统，但保持硬件的开机状态</li>
<li><span class="strong">systemctl poweroff</span>关闭系统并关闭系统电源</li>
<li><span class="strong">systemctl reboot</span>重启系统</li>
<li><span class="strong">systemctl soft-reboot</span>软重启，重新启动用户空间</li>
<li><div class="strong">systemctl suspend</div>挂起(暂停)系统，系统会将当前的会话状态(如打开的应用程序和文件)保存在内存中，并将设备置于低功耗状态</li>
<li><div class="strong">systemctl hibernate</div>
进入休眠状态，休眠模式会将系统的当前状态保存到硬盘(通常是交换分区或交换文件)，然后完全关闭电源，下次开机将从硬盘恢复系统状态</li>
<li><div class="strong">systemctl hybrid-sleep</div>
进入混合睡眠状态，该状态下，系统首先将当前会话状态保存在内存中，并备份一份到硬盘，然后将设备置于低功耗状态。如果之后系统正常唤醒，直接从内存加载数据。如果系统意外关闭(例如电源耗尽)，用户也可以从硬盘恢复数据</li>
<li><div class="strong">systemctl suspend-then-hibernate</div>挂起后休眠，在这种模式下，系统首先进入挂起状态(suspend)，将当前会话的状态保存在内存中，在一定时间后(通常是系统设置的超时设置)，如果没有用户活动，系统会自动切换到休眠状态(hibernate)，将会话状态保存到硬盘中并完全关闭电源，此模式适合用户需要短时间内离开电脑，但又希望在长时间未使用时确保数据安全的状况</li>
<li><div class="strong">systemctl sleep</div>进入睡眠状态，sleep模式在不同发行版中设置可能有所不同，可能执行suspend、hibernate、hybrid-sleep、suspend-then-hibernate中的任意一种，默认情况下，通常可能为suspend-then-hibernate</li>
</ul>
<div class="broadcast color-purple">
<div class="iconfont icon-fengche"></div>
详细文档：<a href="
https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands">
https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands</a></div>

<h4 id="查看系统状态"><a href="#查看系统状态" class="headerlink" title="查看系统状态"></a>查看系统状态</h4><ul>
<li><p><span class="strong">systemctl status</span>查看系统状态</p>
</li>
<li><p><span class="strong">systemctl -&zwnj;-failed</span>列出失败的单元</p>
</li>
<li><p><span class="strong">systemctl list-unit-files</span>列出已经安装的单元</p>
</li>
<li><p><span class="strong">systemctl status PID值</span>查看对应PID进程的状态</p>
</li>
<li><p><span class="strong">systemctl daemon-reload</span>重新加载systemd单元配置，扫描单元变动</p>
</li>
</ul>
<h4 id="单元管理命令"><a href="#单元管理命令" class="headerlink" title="单元管理命令"></a>单元管理命令</h4><p><span class="strong">systemctl [选项] 命令 单元名/模式</span></p>
<ul>
<li>-t unit类型(-&zwnj;-type=unit类型)：在列出unit单元信息时，默认会列出所有类型的单元，通过该选项可以指定只列出某几个类型的单元</li>
<li>-&zwnj;-state=状态：在列出unit单元信息时，默认会列出所有状态的单元，通过该选项可以指定只列出处于所指定状态的单元</li>
<li>-p 属性名(-&zwnj;-property=属性名)：显式属性时，默认显式所有属性，该选项可以用来指定只显示所指定的1个或多个属性</li>
<li>该命令中的单元名，可以使用模式(PATTERN)来匹配多个单元(模式支持使用<span class="tips">*</span>和<span class="tips">?</span>，也支持使用<span class="tips">[]</span>匹配字符范围)，也可以是具体的单元名，当指定具体单元名时，需要指定其完整的单元名，包括扩展名(如：sshd.socket)，以下情况可以省略扩展名：<blockquote>
<blockquote>
<ul>
<li>如果不指定拓展名，systemctl会默认扩展名为<span class="tips">.service</span>，因此如果操作对象的unit类型为service，可以不指定拓展名</li>
<li>挂载点会自动指定为<span class="tips">.mount</span>单元，如：<span class="tips">/home</span>等价于<span class="tips">home.mount</span></li>
<li>设备会自动指定为<span class="tips">.device</span>单元，如：<span class="tips">/dev/sda2</span>等价于<span class="tips">dev-sda2.device</span></li>
<li>某些命令只能用来处理特定类型的单元，此时可以省略单元类型，如：systemctl isolate默认单元类型为target</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="常用的单元管理命令"><a href="#常用的单元管理命令" class="headerlink" title="常用的单元管理命令"></a>常用的单元管理命令</h4><div class="table">

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span class="strong">systemctl status 单元名或PID</span>单元名</td>
<td>查看单元或PID所属单元状态</td>
</tr>
<tr>
<td><span class="strong">systemctl start</span>单元名</td>
<td>启动单元，只能启动已经被systemd加载的单元</td>
</tr>
<tr>
<td><span class="strong">systemctl stop</span>单元名</td>
<td>停止单元</td>
</tr>
<tr>
<td><span class="strong">systemctl restart</span>单元名</td>
<td>重启单元，如果单元未启动，则启动单元</td>
</tr>
<tr>
<td>systemctl try-restart 单元名</td>
<td>重启已启动的单元，如果单元未启动，则不做任何操作</td>
</tr>
<tr>
<td><span class="strong">systemctl reload</span>单元名</td>
<td>让该单元重新加载其配置</td>
</tr>
<tr>
<td>systemctl reload-or-restart 单元名</td>
<td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则启动它</td>
</tr>
<tr>
<td>systemctl try-reload-or-restart  单元名</td>
<td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则不做任何操作</td>
</tr>
<tr>
<td><span class="strong">systemctl enable</span>单元名</td>
<td>开机自启动该单元</td>
</tr>
<tr>
<td><span class="strong">systemctl disable</span>单元名</td>
<td>取消开机自启动</td>
</tr>
<tr>
<td><span class="strong">systemctl reenable</span>单元名</td>
<td>重新启用单元</td>
</tr>
<tr>
<td><span class="strong">systemctl mask</span>单元名</td>
<td>屏蔽单元，该单元将无法手动启动，也无法作为依赖启动</td>
</tr>
<tr>
<td><span class="strong">systemctl unmask</span>单元名</td>
<td>取消屏蔽单元</td>
</tr>
</tbody></table>
</table>
</div>

<h5 id="systemctl-status返回值"><a href="#systemctl-status返回值" class="headerlink" title="systemctl status返回值"></a>systemctl status返回值</h5><ul>
<li><span class="strong">systemctl status</span> [单元名或PID]<br>如果指定了单元，则显示指定单元的运行时状态信息，以及这些单元最近的日志数据。如果指定了PID，那么显示指定PID所属单元的运行状态信息，以及这些单元最近的日志数据，默认输出10行日志，且会截断超长的部分。如果未指定任何单元或PID，那么显示整个系统的状态信息，此时若与 -&zwnj;-all 连用，则同时显示所有已加载单元(可以用-t选项限定单元类型)的状态信息。该命令旨在生成人类可读的输出，如果需要输出方便脚本分析的信息，应该使用systemctl show命令</li>
</ul>
<div class="shell">systemctl status nginx命令的返回值：
<span style="color:#55ff55;">●</span> nginx.service -  Nginx is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3 proxy server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; preset: enabled)
   Active: <span style="color:#55ff55;">active (running)</span>  since Thu 2023-03-09 10:32:25 CST; 1 years 8 months ago
     Docs: man:nginx(8)
 Main PID: 8473 (nginx)
      CPU: 140ms
   CGroup: /system.slice/nginx.service
           ├─6205 nginx: worker process
           └─8473 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf

<p>Nov 18 10:15:42 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …<br>Nov 18 10:15:53 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …</p>
</div>

<div class="show">以nginx为例，systemctl status nginx命令返回值主要包括以下部分：
1. 第一行包含一个符号●，单元的名称，以及单元的简要描述
符号●会根据单元的状态修改颜色和形状：
"inactive"或"maintenance"是一个白色圆圈 ○
"active"是一个绿点 ●
"deactivating"是一个白点 ●
"failed"或"error"是一个红叉 ×
"reloading"是一个绿色的顺时针圆箭头 ↻
2. 第二行为单元Loaded状态，表示单元是否已经加载到了内存中
loaded 表示服务配置文件已加载
error 表示加载时出现问题
not-found 表示未找到该单元的单元配置
bad-setting 表示文件配置文件无法解析
masked 表示单元文件被屏蔽
/lib/systemd/system/nginx.service 为该单元文件路径
enabled 表示服务被设置为开机自启动(disabled表示开机不自启，static表示服务是动态加载的，通常由其他服务触发运行)
preset: enabled：预设值，表示服务被系统默认配置为启用
3. 第三行为单元运行状态
服务状态值通过颜色标识，绿色表示服务正常运行，黄色表示服务处于警告状态(例如未完全启动或有错误)，红色表示服务启动失败或停止
服务状态值通常为"active"或"inactive"，也可能为"activating"(正在启动)或"deactivating"(正在关闭)，如果为"failed"，表示单元可能因为崩溃、错误退出、超时等情况进入了失败状态
since之后表示服务启动时间，以及服务已经运行时间
4. 第四行为文档信息，man:nginx(8)表示nginx的文档在man的第8部分
5. 第五行为主进程信息，包含主进程PID，主进程的命令名称
6. 第六部分通常为资源使用情况，通常可能包含内存使用情况，CPU的占用时间
7. 第七部分为控制组信息，表示该服务所属的 cgroup 路径
8. 第八部分为日志的部分信息
</div>

<h4 id="单元状态查询命令"><a href="#单元状态查询命令" class="headerlink" title="单元状态查询命令"></a>单元状态查询命令</h4><ul>
<li><p><span class="strong">systemctl 或 systemctl list-units </span> 单元名<br>列出systemd已经加载的单元，默认列出处于活动、失败状态和正在处于任务队列的单元，使用-&zwnj;-all选项可以列出所有单元，可以使用-&zwnj;-type选项和-&zwnj;-state选项过滤要列出的单元</p>
</li>
<li><p><span class="strong">systemctl list-sockets [PATTERN]</span> 单元名<br>列出已加载的套接字(socket)单元，并按照监听地址排序。使用-&zwnj;-show-types选项可以显示套接字类型，支持-&zwnj;-all和-&zwnj;-state选项<br><span class="strong">systemctl list-timers [PATTERN]</span><br>列出已加载的定时器(timer)单元，并按照下次执行的时间点排序，支持-&zwnj;-all和-&zwnj;-state选项</p>
</li>
<li><p><span class="strong">systemctl is-active</span> 单元名<br>检查指定的单元中，是否有处于活动(active)状态的单元。如果存在至少一个处于活动(active)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p>
</li>
<li><p><span class="strong">systemctl is-failed</span> 单元名<br>检查指定的单元中，是否有处于失败(failed)状态的单元。如果存在至少一个处于失败(failed)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p>
</li>
<li><p><span class="strong">systemctl show</span> [单元名或JOB]<br>以”属性=值”的形式显示指定单元或任务的所有属性。单元用其名称表示，而任务则用其id表示。如果没有指定任何单元或任务，那么显示管理器(systemd)自身的属性。默认不显示属性值为空的属性，使用-&zwnj;-all选项可以显示所有属性。可以使用-&zwnj;-property选项可以仅显示特定的属性</p>
</li>
<li><p><span class="strong">systemctl cat</span> 单元名<br>显示指定单元的单元文件内容，首行会显示该单元文件的绝对路径</p>
</li>
<li><p><span class="strong">systemctl set-property</span> 属性名 值<br>在运行时修改单元的属性值，主要用于修改单元的资源控制属性值而无需直接修改单元文件，并非所有属性都可以在运行时被修改。 作修改会立即生效，并永久保存在磁盘上，以确保永远有效。如果使用了 -&zwnj;-runtime选项，那么此修改仅临时有效，下次重启此单元后，将会恢复到原有的设置。设置属性的语法与单元文件中的写法相同。如：systemctl set-property foobar.service CPUShares=777，可以同时修改多个属性值，只需依次将各个属性用空格分隔即可。</p>
</li>
<li><p><span class="strong">systemctl list-dependencies</span> [单元名]<br>显示单元的依赖关系，即显示由 Requires=, Requisite=, ConsistsOf=, Wants=, BindsTo= 所形成的依赖关系。如果没有明确指定单元的名称，那么表示显示default.target的依赖关系树。默认情况下，仅以递归方式显示 target 单元的依赖关系树，而对于其他类型的单元，仅显示一层依赖关系(不递归)。 但如果使用了-&zwnj;-all 选项，那么将对所有类型的单元都强制递归的显示完整的依赖关系树。还可以使用 -&zwnj;-reverse, -&zwnj;-after, -&zwnj;-before 选项指定仅显示特定类型的依赖关系</p>
</li>
</ul>
<h3 id="systemd-journald"><a href="#systemd-journald" class="headerlink" title="systemd-journald"></a>systemd-journald</h3><p>systemd-journald是systemd内置的日志收集和存储服务</p>
<h4 id="日志文件存储路径"><a href="#日志文件存储路径" class="headerlink" title="日志文件存储路径"></a>日志文件存储路径</h4><p>systemd-journald保存日志的方式有两种：<span class="tips">volatile</span>(临时存储，存储于内存)和<span class="tips">persistent</span>(持久化存储，存储于磁盘)，当前使用哪种存储方式取决于配置文件中的Storage配置项：</p>
<ul>
<li>持久化日志的存储位置为：<span class="tips">/var/log/journal/</span></li>
<li>临时日志的存储位置为：<span class="tips">/run/log/journal/</span>，该路径下存储的日志会在系统重启时丢失</li>
</ul>
<p>systemd-journald收集的日志文件通常分为两种，一种是当前处于活跃状态的(active)，通常文件名为<span class="tips">system.journal</span>，活跃状态的文件是journald正在写入的文件，通过journalctl命令删除日志时无论如何不会删除活跃的日志文件；另一种是已经归档的(archived)日志文件，文件名通常包含日志时间范围和系统标识符的哈希值，类似于<span class="tips"><code>system@0-000027b7a-000158412d.journal</code></span>，journald不会向这类文件再写入东西，这些通常是旧的日志文件。</p>
<h4 id="journalctl日志命令"><a href="#journalctl日志命令" class="headerlink" title="journalctl日志命令"></a>journalctl日志命令</h4><p>systemd-journald是以二进制格式存储日志的，不能使用传统vim、cat等工具直接打开，需要使用<span class="tips">journalctl</span>命令</p>
<p><span class="strong">journalctl [选项]</span></p>
<ul>
<li>默认情况下将显示所有日志，旧的日志显示在前，以分页形式显示，长行会被截断为屏幕宽度，可以使用左右箭头查看截断部分</li>
<li>-r 倒叙查看，最新的日志排于前</li>
<li>字段=值：过滤出指定的字段，如：_PID=1234(查看该PID服务的日志)，_UID=1111(查看该用户的日志)</li>
<li>-n 值：显示指定数量的日志条目</li>
<li>-u 服务名：查看指定服务的日志</li>
<li>-&zwnj;-since 日期：查看指定日期之后的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li>
<li>-&zwnj;-untile 日期：查看指定日期之前的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li>
<li>-f 实时查看日志，类似于tail -f命令</li>
<li>-p 日志等级：查看指定等级以上的日志，可取值有emerg, alert, crit, err, warning, notice, info, debug，也可以使用0-7的值依次代替这些等级</li>
<li>-o 输出格式：指定日志的输出格式，常用的输出格式有<blockquote>
<blockquote>
<ul>
<li>short：简洁格式</li>
<li>verbose：详细格式</li>
<li>json：JSON格式</li>
<li>cat：仅显示日志内容，不包含其他信息</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>-&zwnj;-no-pager 禁用分页模式</li>
<li>-&zwnj;-disk-usage 显示所有日志文件在当前磁盘的占用情况</li>
<li>-&zwnj;-rotate 立即开始日志轮换，将当前活跃的日志文件立即归档并重命名，然后标记为archived，然后新建新的日志文件作为活跃文件</li>
<li>-&zwnj;-vacuum-size=值：删除最早的归档日志，直到日志所占用空间小于指定值，接受K、M、G、T单位</li>
<li>-&zwnj;-vacuum-time=值：删除早于指定时间跨度的归档日志，单位默认为s，接受m、h、days、weeks、months、years单位</li>
<li>-&zwnj;-vacuum-files=值：只保留指定数量的归档日志文件</li>
<li>-&zwnj;-sync 立即将日志同步到磁盘，在同步操作完成之前，此调用不会返回</li>
</ul>
<div class="broadcast color-purple">
完整命令和选项参考官方文档：<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/journalctl.html">journalctl命令</a></div>


<h4 id="日志服务配置文件"><a href="#日志服务配置文件" class="headerlink" title="日志服务配置文件"></a>日志服务配置文件</h4><p>日志配置文件<span class="tips">journald.conf</span>的主文件路径是systemd编译时指定的，无法修改，这些路径包括<span class="tips">/etc/systemd/</span>、<span class="tips">/run/systemd/</span>、<span class="tips">/usr/local/lib/systemd/</span>、<span class="tips">/usr/lib/systemd/</span>，它们的优先级也是固定的，journald会按照上述顺序查找配置文件，只会加载第一个找到的文件。主配置文件用来定义系统默认配置，一般情况下，绝大部分Linux发行版的主配置文件只有<span class="tips">/etc/systemd/journald.conf</span>文件，且该文件中的配置项是被注释掉的，这是因为日志的默认配置在编译时内置到了journald服务中，journald.conf文件中的内容只是对这些默认值的说明，用来帮助管理员了解可以配置的选项及其默认行为。</p>
<p>除了主配置文件，日志服务还会从<span class="tips">/usr/lib/systemd/journald.conf.d/</span>、<span class="tips">/usr/local/lib/systemd/journald.conf.d/</span>、<span class="tips">/etc/systemd/journald.conf.d/</span>路径中查找配置文件，这些路径中的配置会覆盖系统的默认主配置，且这些路径中的配置文件会按上述顺序全部加载，对于只接受单个值的配置项，后面的配置会覆盖前面的，而对于接受多个值的配置项，所有配置都将生效。换而言之，<span class="tips">/etc/systemd/journald.conf.d/</span>路径下的配置文件优先级将是最高的，同一目录中的配置文件会按文件名字典顺序加载。</p>
<p>通常情况下，如果要修改日志的配置，只需要修改/etc/systemd/journald.conf文件即可，如果需要为不同的Unit单元或服务定制专属日志配置，则可以在/etc/systemd/目录中新建journald.conf.d(该目录通常需要自行创建)，然后在该目录中创建新的日志配置文件，如：my-global-settings.conf，该文件的优先级将是最高的，/etc/systemd/journald.conf文件的默认配置如下：</p>
<div class="shell">[Journal]
#Storage=auto
#Compress=yes
#Seal=yes
#SplitMode=uid
#SyncIntervalSec=5m
#RateLimitIntervalSec=30s
#RateLimitBurst=10000
#SystemMaxUse=
#SystemKeepFree=
#SystemMaxFileSize=
#SystemMaxFiles=100
#RuntimeMaxUse=
#RuntimeKeepFree=
#RuntimeMaxFileSize=
#RuntimeMaxFiles=100
#MaxRetentionSec=
#MaxFileSec=1month
#ForwardToSyslog=yes
#ForwardToKMsg=no
#ForwardToConsole=no
#ForwardToWall=yes
#TTYPath=/dev/console
#MaxLevelStore=debug
#MaxLevelSyslog=debug
#MaxLevelKMsg=notice
#MaxLevelConsole=info
#MaxLevelWall=emerg
#LineMax=48K
#ReadKMsg=yes
#Audit=no
</div>

<h4 id="配置文件语法-1"><a href="#配置文件语法-1" class="headerlink" title="配置文件语法"></a>配置文件语法</h4><ul>
<li><p><span class="strong">Storage=</span><br>指定日志数据的存储方式，可以为以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">volatile</span>：日志只存储于内存中，存储位置为：<span class="tips">/run/log/journal</span>,存储内容会在系统重启后丢失</li>
<li><span class="strong">persistent</span>：日志存储在磁盘上，存储位置为：<span class="tips">/var/log/journal</span>，但在系统引导初期(boot)以及磁盘无法写入时将回滚为volatile模式</li>
<li><span class="strong">auto</span>：如果目录/var/log/journal 存在，则写入磁盘，否则将回滚为volatile模式</li>
<li><span class="strong">none</span>：关闭日志存储，所有日志将被丢弃(但被转发到其他目标位置，如被转发到控制台、内核日志缓冲区或 syslog 套接字的配置仍将有效)</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">Compress=</span><br>指定日志是否压缩，需要指定一个boolean值，默认为yes，此时会将大于默认阈值512bytes的数据进行压缩。也可以直接指定一个值，表示进行压缩的阈值，可以使用K、M、G等单位</p>
</li>
<li><p><span class="strong">Seal=</span><br>指定是否为持久化的日志文件启用安全密封(FSS)，以保护日志文件免受纂改，需要指定一个boolean值，默认为yes</p>
</li>
<li><p><span class="strong">SplitMode=</span><br>指定日志的分割方式,可以取以下值:</p>
<blockquote>
<blockquote>
<ul>
<li><soan class="strong">none</soan>：默认值,不分割日志</li>
<li><soan class="strong">uid</soan>：按用户ID分割日志</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">RateLimitIntervalSec=,RateLimitBurst=</span><br>用于限制日志的写入速率，防止占用太多系统资源，默认值为30s内最多允许写入1000条日志，多余的日志会被丢弃。RateLimitIntervalSec用于指定限制时间，默认值为30，可以使用s、min、h、ms、us单位；RateLimitBurst用于指定上述时间内的限制写入条数，默认值为1000，二者需要搭配使用。当达到限制速率时，systemd-journald 会生成类似日志信息：”Rate limit reached for messages, suppressing X messages from Y services”，X表示被丢弃的日志数量，Y表示服务来源。将值设置为0表示不进行任何限制</p>
</li>
</ul>
<ul>
<li><p><span class="strong">RuntimeMaxUse=,SystemMaxUse=</span><br>指定内存，磁盘中日志最大占用空间，默认值均为当前文件系统大小的10%，上限为4G，当日志存储空间接近限制时，journald会删除旧的归档日志</p>
</li>
<li><p><span class="strong">RuntimeKeepFree=,SystemKeepFree=</span><br>指定需要为内存，磁盘保留多大空闲空间，默认值均为当前文件系统大小的15%，上限为4G。当内存或磁盘空间被非日志文件占用，剩余空间低于该设置的值时，journald将停止写入新日志，但不会去删除旧日志(是否删除旧日志取决于RuntimeMaxUse=或SystemMaxUse=设置的阈值)</p>
</li>
<li><p><span class="strong">RuntimeMaxFileSize=,SystemMaxFileSize=</span><br>指定单个日志文件的最大大小，达到此大小时，journald会创建一个新文件，默认值为SystemMaxUse= 和 RuntimeMaxUse= 的1/8，最大上限为128M，即如果SystemMaxUse的1/8超过了128M，上限仍为128M，如果启用了日志压缩，最大限制为4G</p>
</li>
<li><p><span class="strong">RuntimeMaxFiles=,SystemMaxFiles=</span><br>指定日志文件的最大数量，达到限制后，旧的日志文件会被删除，默认值为100</p>
</li>
<li><p><span class="strong">MaxFileSec=</span><br>指定单个日志文件能够记录数据的最长时间，一旦时间达到这个值，当前日志文件将被关闭并归档，journald 会启动一个新的日志文件来存储后续日志，默认值为1个月，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。如果日志数据量很大时，文件也有可能会因为达到SystemMaxFileSize值而被强制轮换，导致单个文件中记载的时间不足该指定值</p>
</li>
<li><p><span class="strong">MaxRetentionSec=</span><br>指定日志的最长保留时间。如果日志文件的最后修改时间早于这个时间阈值，它们将被删除。默认值为0，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。</p>
</li>
<li><p><span class="strong">SyncIntervalSec=</span><br>控制 journald 将内存中缓存的日志条目写入磁盘以持久化保存的时间间隔，默认值为5min写入一次。CRIT、ALERT 或 EMERG级别的日志会被立即写入磁盘而不受此设置影响，此设置仅适用于ERR、WARNING、NOTICE、INFO、DEBUG 级别的日志消息</p>
</li>
<li><p><span class="strong">ForwardToSyslog=, ForwardToKMsg=, ForwardToConsole=, ForwardToWall=, ForwardToSocket=</span><br>指定是否需要将日志转发到传统日志服务(syslog，默认为no)、内核日志缓冲区(/dev/kmsg，默认为no)、控制台(默认为no，可以通过TTYPath指定转发到哪个控制台)、所有登录用户(类似于wall命令，默认为yes)、Socket服务(该服务为/run/systemd/journal/socket上所监听的服务，如果要指定该配置则需要指定该服务的地址，默认无转发)，以上设置，默认仅启用转发到wall(且只有出现emerg级别的日志时才转发，参考MaxLevelSocket配置)</p>
</li>
<li><p><span class="strong">TTYPath=</span><br>指定日志转发的TTY设备设备路径，仅在 ForwardToConsole=yes 时生效，默认为/dev/console</p>
</li>
<li><p><span class="strong">MaxLevelStore=, MaxLevelSyslog=, MaxLevelKMsg=, MaxLevelConsole=, MaxLevelWall=, MaxLevelSocket=</span><br>指定存储、转发到syslog、内核日志缓冲区、控制台、所有登录用户、Socket服务的日志其日志等级，可选值有：emerg、alert、crit、err、warning、notice、info、debug，以下为默认值：</p>
<blockquote>
<blockquote>
<ul>
<li>MaxLevelStore=debug</li>
<li>MaxLevelSyslog=debug</li>
<li>MaxLevelKMsg=notice</li>
<li>MaxLevelConsole=info</li>
<li>MaxLevelWall=emerg</li>
<li>MaxLevelSocket=debug</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">ReadKMsg=</span><br>控制journald是否读取内核环形缓冲区(/dev/kmsg)中的日志消息，这些消息通常由内核及其模块生成，是系统启动、硬件事件和内核日志的重要来源，默认为yes</p>
</li>
<li><p><span class="strong">Audit=</span><br>控制 journald 是否从内核审计子系统(Audit Framework)读取审计日志，审计日志记录系统的安全相关事件(如用户登录、权限更改等)，通常由内核的审计功能生成，默认为yes</p>
</li>
<li><p><span class="strong">LineMax=</span><br>指定journald从stdout/stderr读取流数据，并将其转换为记录日志时允许的最大行长度，默认为48k，超出部分会被journald截断并添加…后缀，表示此行已被截断。可以使用K、M、G、T为单位，最小可设置的值为79(bytes)，小于该值的设置会被提升到79bytes</p>
</li>
</ul>

        </div>
    </div>
    <div class="post-nav">
        
            
                <div class="post-next">
                    <a href="/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/">下一篇：C语言 </a>
                </div>
                 
    </div>
    <div class="container">
        <!--设计来源于B站-季夏小贞-->
        <div class="big-head"></div>
        <div class="ears"></div>
        <div class="body"></div>
        <div class="paws-front"></div>
        <div class="paws-back"></div>
        <div class="details"></div>
        <div class="tail"></div>
        <div class="sleep">
          <span class="s1">z</span>
          <span class="s2">z</span>
          <span class="s3">z</span>
          <span class="s4">z</span>
          <span class="s5">z</span>
        </div>
    </div>
</div>
<div class="right-menu">
    <a class="iconfont back-top" href="javascript:">&#xe655;</a>
    <div class="husky"></div>
  </div>
</div>

<script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.bumpytext.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/highlightjs-line-numbers.min.js"></script>
<script src="/blog/js/article.js"></script>

</body></html>